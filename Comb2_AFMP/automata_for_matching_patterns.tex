%-*- coding:UTF-8 -*-
% 字符串匹配.tex
\documentclass[UTF8]{ctexart}
\usepackage{geometry}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{amsthm}
\usepackage{listings} %插入代码
\usepackage{xcolor} %代码高亮
\usepackage{blkarray}
\usepackage{diagbox}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{color}
\usepackage{multirow}
\usepackage[all,pdf]{xy}
\usepackage{verbatim}   %comment
\usepackage{cases}
\usepackage{clrscode3e}	% need clrscode3e package which is not included in CTex.

% THEOREM Environments --------------------------------------------------------
\newtheorem{thm}{Theorem}[subsection]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{prob}[thm]{Problem}
\newtheorem{mthm}[thm]{Main Theorem}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\numberwithin{equation}{subsection}
% MATH ------------------------------------------------------------------------
\DeclareMathOperator{\RE}{Re}
\DeclareMathOperator{\IM}{Im}
\DeclareMathOperator{\ess}{ess}
\newcommand{\eps}{\varepsilon}
%\newcommand{\To}{\longrightarrow}  conflict with \package{clrscode3e}p
\newcommand{\h}{\mathcal{H}}
\newcommand{\s}{\mathcal{S}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\BOP}{\mathbf{B}}
\newcommand{\BH}{\mathbf{B}(\mathcal{H})}
\newcommand{\KH}{\mathcal{K}(\mathcal{H})}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Complex}{\mathbb{C}}
\newcommand{\Field}{\mathbb{F}}
\newcommand{\RPlus}{\Real^{+}}
\newcommand{\Polar}{\mathcal{P}_{\s}}
\newcommand{\Poly}{\mathcal{P}(E)}
\newcommand{\EssD}{\mathcal{D}}
\newcommand{\Lom}{\mathcal{L}}
\newcommand{\States}{\mathcal{T}}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\seq}[1]{\left<#1\right>}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\essnorm}[1]{\norm{#1}_{\ess}}


% Some setup
\pagestyle{plain}
\geometry{a4paper, top=2cm, bottom=2cm, left=2cm, right=2cm}
\CTEXsetup[format={\raggedright\bfseries\Large}]{section}
\lstset{numbers=left, %设置行号位置
        numberstyle=\small, %设置行号大小
        keywordstyle=\color{blue}, %设置关键字颜色
        commentstyle=\color{purple}, %设置注释颜色
        %frame=single, %设置边框格式
        escapeinside=``, %逃逸字符(1左面的键)，用于显示中文
        breaklines, %自动折行
        extendedchars=false, %解决代码跨页时，章节标题，页眉等汉字不显示的问题
        %xleftmargin=2em,xrightmargin=2em, aboveskip=1em, %设置边距
        tabsize=4, %设置tab空格数
        showspaces=false %不显示空格
       }

% About math
\newcommand{\rmnum}[1]{\romannumeral #1}
\newcommand{\Emph}{\textbf}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\resetcounter}{\setcounter{equation}{0}}
\newcommand{\equsuf}[1][x]{\equiv_{\textit{Suff(#1)}}}	
\newcommand{\Suff}{\textit{Suff}}
\newcommand{\len}[1][x]{\textit{length}_{#1}}

% section deeep to 3 1.1.1
\setcounter{secnumdepth}{3}

\begin{document}

\title{\Huge 基于自动机原理的字符串匹配}
\vspace{2cm}
\author{\Large Trasier}
\date{\today}
\maketitle


\section{前言}

	字符串匹配的相关算法旨在解决在一个较大规模的文本中查询模式串的匹配情况。
	这里的模式串可能是一系列单词，也可能是一个强大的正则表达式。有许许多多
	的算法可以解决字符串匹配的相关问题，而这些算法往往包括\Emph{预处理}以及\Emph{搜索}
	两个阶段。其中一部分算法在搜索阶段往往采用\Emph{自动机}这一载体，自动机的优势
	主要在于通过状态的跃迁加快查找的速度，同时支持在线查找，可以处理大文件。
	
	文中涉及的算法主要使用\Emph{最小化的确定性有穷自动机}，用来处理\Emph{re-matching}、
    \Emph{dictinoary-matching}以及\Emph{index-matching}等问题。

\section{符号说明}
	
	简单规定一下使用的符号说明，后面的自动机算法都尽量以形式化的方法说明。
	
\subsection{Alphabet and words}
	
	\noindent
    $A$表示一个字符集合，$a$表示$A$的一个元素。				\\
	$u$表示一个单词，$|u|$表示长度，$u_j$表示第$j$个字符。	\\
	$u \cdot v$或$uv$表示单词$u$连接单词$v$，$u^0 = \varepsilon$。\\
	当$u,v,w$满足$u = wv$时，有$uw^{-1} = v, vu^{-1} = w$	\\
	当$\exists u^0, u^1, u=u^0vu^1$成立时，称$v$是$u$的factor。
	此时若$v \neq u$并且$u^0=\varepsilon or u^1=\varepsilon$，我们称$v$是$u$的proper factor。
	
\subsection{Languages}
	
	\noindent
	$U$表示一个语言集合，$U \subseteq A^*$.	\\
	$pref(U), fact(U), suff(U)$分别表示语言$U$的某个前缀、子串、后缀。	\\
	$Pref(U), Fact(U), \Suff(U)$分别表示语言$U$的所有前缀、子串、后缀的集合。	\\
	$|U| = \sum_{u \in U} |u|$。
	
	基于语言$W$的字符串$u$的右端上下文表示集合$\{ u^{-1}w | w \in W \}$。使用$\equiv_W$表示如下等价关系：
	\[
		\forall u,v \in A^*, u^{-1} W = v^{-1} W
	\]
	这就是语言集$W$上的右端同余关系。
	
	$\equiv_W$这个符号还是挺重要的，需要搞清楚定义，后面后缀自动机通篇都在使用同余关系
	（同余关系与商代数是离散数学的知识，没印象的可以恶补一下）。	\\
	举个例子，$W = {abcbc}$，那么字符串$abc$的右端上下文就是$\{ \varepsilon, b, bc \}$
	
	
\subsection{Regular expressions}

	就是平时用的RE。
	
\subsection{Finite automata}
	
	通常FA的定义是一个五元组，因为符号集合其实就是$A$。因此，这里简化一下，使用四元组来定义一个FA。
	$Q$表示状态集合，$i$表示初始状态，$T, T \subseteq Q$表示终结态，$E$表示状态转换函数。
	如果把一个FA理解成一个图的话，$Q, i, T$其实都是点，而$E$则表示边的集合。
	同时，$i$的入度为0。
	边往往采用三元组描述$(p, a, q)$，$p,q \in Q$，表示当前字符为$a$时，可由状态$p$转换为状态$q$。
	也可以表示为$\delta(p, a)=q$，从而可以得到如下递推式
	\[
		\delta(p, u) =
		\left\{
		\begin{aligned}
			&p,		  &if\ u=\varepsilon,	\\
			&\delta(\delta(p, a), v), &if\ u=av,	\\
			&undefined,  &otherwise.
		\end{aligned}
		\right .
	\]
	其实这个递推式就是描述了一个在自动机上搜索$u$的过程。
	
\section{DFA的抽象数据结构}

	很多模式匹配的算法都依赖于DFA的具体实现的数据结构，重点是能够实现DFA的转换函数。
	下面列举了主要的五种方法：
	transition matrix, adjacency lists, transition list, failure function, table-compression。
	
	我们将不同方法查询$\delta(p,a)$的时间花费称为$delay$, $delay$表示在查询下一个字符前花费在查询$a$的时间。
	一般来说，允许状态分支的数据结构的$delay$为常数，如transition matrix；而基于比较的数据结构的查询时间为
	$O(log |A|)$。
	
\subsection{Transition matrix}

	转移矩阵式最简单的DFA的实现方式，这也不难想象。
	还是讲DFA想象成一个directed graph，这其实就是个邻接矩阵。
	显然它的空间复杂度为$O(|Q| \times |A|)$，延迟为$O(1)$。
	它的缺陷和优势与邻接矩阵几乎相同。
	
\subsection{Adjancy lists}
	
	这个邻接表其实也和普通Graph里的邻接表是一致的。
	因此，它的空间复杂度为$O(|Q| + |E|)$，延迟为$O(log \min(|Q|, |A|))$。
	其实这里一般携程$O(log |A|)$就好了，当$|Q|<|A|$时，导致每个结点的出度至多为$|Q|$。
	因此，综合起来就是$O(log \min(|Q|, |A|))$。
	
\subsection{Transition list}
	
	这东西实际上就是个hash。（当发现没有比hash好很多的数据结构时，很多工程和算法都会用hash代替复杂数据结构）
	显然，可以把$e \in E$看成一个三元组$(p, a, q)$。
	这个hash的主要任务就是快速地映射$(p,a)$。
	空间至少是$O(|E|)$，时间平均为常量。
	
\subsection{Failure function}
\label{sub:failure_function}

	\Emph{Failure function}挺重要的，也挺有效的，后面的几种自动机模型都一定程度上使用了failure function。
	其实FA包括DFA, NFA, $\varepsilon$-NFA，对于NFA而言，可能存在$\delta(p,a)=q_0, \delta(p,a)=q_1$。
	然而DFA，对于给定的输入字符$a$以及当前状态$p$，仅存在唯一的$q, \delta(p,a)=q$。
	它的空间复杂度和时间复杂度都是线性的。	\\
	
	failure function是AC自动机算法中最不好理解的部分，一直没有弄懂fail都低是干嘛的，其实就是个线索树。
	我是这么理解fail函数的：
	使用确定化将NFA转化为DFA时，DFA的结点可能代表了NFA的几个状态集合，因为$\delta$函数指向的新的状态可能
	也是原始状态的集合。若还使用上述的方法就会造成空间爆炸。因此，这里使用fail函数将相关的状态关联起来，
	不断的递归进行检索，可以一定程度上降低空间复杂度。
	
	\begin{defn}
		$\gamma$表示函数$Q \times A \rightarrow Q$, $f$表示函数$Q \rightarrow Q$。
		通过$\gamma f$可重写$\delta$的递推式。
		\[
			\delta(p,a) =
			\left\{
			\begin{aligned}
				&\gamma(p, a), 		&if\ \gamma(p, a) \neq Null,	              \\
				&\delta(f(p), a), 	&if\ \gamma(p, a) = \text{Null and } f(p) \neq Null,	\\
				&i,					&otherwise.
			\end{aligned}
			\right .
		\]
	\end{defn}
	\begin{codebox}
	\Procname{$\proc{FailureFunction-Transition}(p, a)$}
		\li	\While $p \neq \const{nil}$ and $\gamma(p,a) = \const{nil}$
		\li	\Do
				$p \gets F[p]$
			\End
		\li \If $p \neq \const{nil}$
		\li		\Then $p \gets \gamma(p,a)$
		\li		\Else $p \gets i$
				\End
		\li	\Return p
	\end{codebox}
	假设使用adjancy lists表示$\gamma$，则空间复杂度为$O(|Q| + |E'|)$。
	这里$E' = \{(p,a,q) | (p,a,q) \in E \ and\ \gamma(p,a) is defined \}$.
	时间复杂度为$O(|Q| \times log |A|)$。
	
\subsection{Table-compression}

	这个模型其实没什么，就是在failure function的基础上使用了邻接矩阵。
	$fail, |fail|=|Q|$还是原来的failure函数，$base, |base|=|Q|$表示状态$p$对应的出边对应的其实地址，
	$check, |check|=|Q|\times|A|$表示对应结点的状态，$target, |target|=|Q|\times|A|$ 表示下一状态。
	重写递推式
	\[
		\delta(p, a) =
		\left\{
		\begin{aligned}
			&target[base[p]+a], 	&if\ check[base[p]+a] = p		\\
			&\delta(fail(p), a),	&if\ check[base[p]+a] \neq p
		\end{aligned}
		\right .
	\]
	显然空间复杂度为$|Q| \times |A|$，时间复杂度降低为$O(|Q|)$。
	
	个人感觉，并没好到哪里去。
	
\section{Matching regular expressions}

\subsection{前言}

    \begin{prob}
        (正则表达式匹配) 给定一个正则表达式x, 找到x表示的所有字符串在目标串y上的位置。
    \end{prob}
	经典的算法是构建表达式$x$的$NFA$，将$y$作为自动机上的搜索串，
	查找所有可能的$y$的前缀，满足$Pref(y) \in A^*Lang(x)$。
	构建这个自动机的时间和空间均是$O(|x|)$，匹配$y$的时间是$O(|x||y|)$，
	识别$y$的每个字符的时间是$O(|x|)$。
	
\subsection{RE自动机}

	\begin{thm} $x$表示一个正则表达式，一定存在一个可以识别$x$并满足如下条件的$\varepsilon-NFA$：
		\begin{enumerate}[(1)]
		
			\item 状态总数上界为$2|x|$；
			
			\item 标号为$a$的边的上界为$|x|$，标号为$\varepsilon$的边的上界为$4|x|$；
			
			\item 每个状态的入度和出度的总和不超过2，并且当且仅当标号为$\varepsilon$时总和为2。
			
		\end{enumerate}
	\end{thm}
	
	这个定理还是比较重要的，这个为RE自动机算法的空间复杂度$O(|x|)$和时间复杂度$O(|x||y|)$奠定了基调。
	这个定理也比较好证明，基本思路是对两个表达式$x,y$进行数学归纳。证明$x+y, x \cdot y, x^*$也满足上述定理。
	
	\begin{thm}
		$\delta(x)$表示由正则表达式$x$构建的$\varepsilon-NFA$，空间和时间复杂度均满足$O(|x|)$。
	\end{thm}
	
\subsection{使用RE自动机搜索}

	这里面有个稍微难理解的东西$\varepsilon 闭包$。因为$\varepsilon-NFA$中的状态转移可能由$\varepsilon$引发，
	因此，对于$\delta(p,\varepsilon) = q$，当搜素到$p$时，同时也要把$q$加入带搜索集合中。
	因为，这个状态发生的可能。（DFA可以这个东西，但是会产生状态爆炸的问题。）
	
	使用RE自动机搜素主要包括\proc{Closure}和\proc{Transitions}两个过程。
	\begin{codebox}
	\Procname{$\proc{Closure}(E, S)$}
		\li $R \gets S$
		\li	$\vartheta \gets \const{EmptyQueue}$
		\li	\For p \kw{in} S
		\li		\Do $\func{Enqueue}(\vartheta, p)$
				\End
		\li \While not $\func{QueueIsEmpty}(\vartheta)$
		\li		\Do
					$p \gets \func{Dequeue}(\vartheta)$
		\li			\For $(p,a,q)$ \kw{in} E
		\li				\Do
							\If q \kw{not in} R
		\li						\Then $R \gets R + \{q\}$
		\li							  $\func{Enqueue}(\vartheta, q)$
								\End
						\End
				\End
		\li \Return R
	\end{codebox}
	
	\begin{codebox}
	\Procname{$\proc{Transitions}(E, S, a)$}
		\li $R \gets {\O}$
		\li	\For p \kw{in} S
		\li		\Do
					\For $(p,a,q)$ \kw{in} E
		\li				\Do
							$R \gets R + \{q\}$
						\End
				\End
		\li	\Return R
	\end{codebox}
	
	这样一个自动机的基本功能是用来检测字符串$y$是否可以被正则表达式$x$所表示，这样一个过程称为\Emph{Tester}。
	\begin{codebox}
	\Procname{$\proc{Tester}(x, y)$}
		\li	\proc{Build-RE} $(Q, i, \{t\}, E)$ of $x$
		\li $C \gets \proc{Closure}(E, \{i\})$
		\li	\For $j \gets 1$ \To $\attrib{y}{length}$
		\li		\Do
					$C \gets \proc{Closure}(E, \proc{Transition}(E, C, y[j]))$
				\End
		\li \Return $t \kw{in} C$
	\end{codebox}
	
	\begin{prop}
		给定一个正则表达还是$x$，测试单词$y$属于$Lang(x)$的时间复杂度为$O(|x||y|)$，空间复杂度为$O(|x|)$。
	\end{prop}
	
	\begin{proof}
		其实只能说Transitions和Closure可以在$O(|Q|)=O(|x|)$中实现，这样Tester的复杂度就是$O(|y||x|)$。
	\end{proof}
	
	Tester只能做判定，还是回到最初的问题，识别所有可以匹配$x$的$fact(y)$，将这样的$fact(y)$在y中的右边界的位置称为$end-point$。
	做法很简单，在每次Tester的循环中都将初始状态$i$加入$C$中，表示每次搜索可能都是从初始状态开始。
	这样就得到了过程Matcher。
	
    \begin{codebox}
    \Procname{$\proc{Matcher}(x,y)$}
        \li	\proc{Build-RE} $(Q, i, \{t\}, E)$ of $x$
        \li $C \gets \proc{Closure}(E, \{i\})$
        \li \func{occurrence} \If t \kw{in} C
        \li	\For $j \gets 1$ \To $\attrib{y}{length}$
        \li     \Do
                    $C \gets \proc{Closure}(E, \proc{Transition}(E, y[j], a))$
        \li         \func{occurrence} \If t \kw{in} C
                \End
    \end{codebox}
	
\subsection{时间和空间的trade-off}
	
	上述方法是使用了$\varepsilon-NFA$这种自动机模型，其实也可以使用$DFA$。
	但是在对状态进行确定化时，往往会产生空间爆炸。
	如$x = a(a+b)^{m-1}$，识别$A^*Long(x)$的$DFA$需要$2^m$个状态。
	因为，它需要记录$m$个后缀字符。在构建$DFA$时往往采用延迟构建技巧。
	
	% Lazy Construction这东西在vEB里面就见到了，在那里面还比较好理解
	% 但在DFA的建立里面就理解乏力了？莫非等价于failure function。

\section{Matching Dictonary}

\subsection{前言}
	
	% dictionary-matching problem
	\begin{prob}
		（字典匹配问题）给定有限的单词集合$X$，找到$\forall x \in X$在字符串$y$中匹配的所有位置。
	\end{prob}
	
	解决这个问题的经典算法是Aho and Corasick（AC自动机）。
	它的基本思路思路是实现一个基于线性空间复杂度的$DFA$识别语言$A^*X$。
	这个$DFA$的实现往往会结合邻接表和failure function。
	
	\begin{mthm}
		\Emph{(Aho and Corasick 1975).} 面向单词集合$X$和字符串$y$的字典匹配问题，可以在如下条件内实现：
		\begin{itemize}
			\item 在预处理阶段，构建基于$X$的可识别语言$A^*X$的$DFA$，时间复杂度为$O(|X|\times|A|)$，空间复杂度为$O(|X|)$
			\item 在搜索阶段，使用$y$在$DFA$上进行搜索，时间复杂度为$O(|y|\times|A|)$，空间复杂度为常量，$delay$的时间花销为$O(|X|\times|A|)$
		\end{itemize}
	\end{mthm}
	% delay很有可能比整体的时间复杂度大，怎么破？
	
	首先思考问什么一直强调这个自动机是能够识别语言$A^*X$的。
	\begin{proof}
		若$\forall x \in X$并且$x$出现在$y$中，即$x \in fact(y) \Rightarrow y=uxv \Rightarrow y=A^*xv$。
		这也意味着，使用$y$在自动机$DFA$中进行搜索时，遇到的任何对应终$A^*x$终结态的位置即为所求。
	\end{proof}
	
\subsection{Dictionary-matching automata}
	
	为了形式化的定义识别语言$A^*X$的$DFA$，引入基于语言$U$、字符串$v$的映射$h_U: A^* \rightarrow Pref(U) $, 并且
	\[
		h_U(v) = v', v' \in \Suff(v) \cap Pref(U), |v'| \ge \max_{vv \in \Suff(v)\cap Pref(U)} {|vv|}
	\]
	从而，可以得到字典匹配问题的$DFA$的形式化定义
	\begin{defn}
		若$X$表示一个有限语言集合，那么可以识别语言$A^*X$的确定性有限自动机可以表示为
		\[
			\Big( Pref(X), \varepsilon, Pref(X) \cap A^*X, \{(p,a,h_X(pa) | p \in Pref(X), a \in A\} \Big)
		\]
	\end{defn}
	这个定义很重要也很有意思，想要理解AC自动机到底在干嘛主要需要理解好这个定义。
	$(Q, i, T, E)$四元组表示一个$FA$。
	首先，最好理解的是初始状态为$\varepsilon$表示一个空串，这是显然的。
	
	其次，状态集合为$Pref(X)$，表示$X$的所有前缀。这里$X$并不是一个正则表达式，
	因此也可以比表示为$X = \bigcap_{x \in X} Pref(x)$，（这也就意味着其实AC自动机上的每个结点其实表示的是一个前缀而非一个字符，
	但是只存一个字符显然可以省空间，因此仅存一个字符，从trie的根一直搜索到当前结点的路径就是这个前缀，这是后话，留个印象）。
	那为什么要用前缀呢？
	关键是要识别$A^*X$。不妨想象$X={x}$，因此，问题转化成两个字符串的匹配。
	可以直接使用$O(|x||y|)$的朴素算法在字符串$y$的每个位置，搜索是否可以匹配一个$x$，
	其实就是一个字符一个字符的比较是否和$x$中对应的字符相等，
	因此，$\forall i,j < |x|, i<j$当且仅当搜索到了$i$才可以搜索到后续位置$j$。
	不难发现，$i,j$其实代表的都是$x$的位置。
	那么，对于$|X|>1$，其实我们也要找到能匹配的所有前缀，才会最终判定是否匹配完整的$x, x \in X$。
	
	从而我们可以理解终结状态是一个集合，即$Pref(X) \cap A^*X$，
	其实就是$\forall x \in X$对应的状态。（可以理解成匹配字典中一个完整的单词）
	
	最后，是转换函数${(p,a,h_X(pa) | p \in Pref(X), a \in A}$，这里使用了$h_U$的定义，不妨令$\delta(p,a)=q$
	$q \in Pref(X)$这个最好理解，因为$q \in Q$这是必然的，因此$q \in Pref(X)$。
	$q \in \Suff(pa)$这个也还好理解，毕竟是要匹配$A^*X$，可以把任何$pa$的前缀字符归为$A^*$，我们只需要后缀。
	关键是为什么我们需要这个新的前缀$q, q \in Pref(X)$最长。
	（这也是为什么Dictionary-matching时，failure function是靠谱的，这也是为什么很多人都说AC自动机=trie+kmp，确实可以从kmp的next数组这儿理解）。
	
	\begin{lem}
		不妨令$U \subseteq A$，那么有
		\begin{enumerate}[(1)]
			\item $v \in A^*U \text{iff } h_U(v) \in A^*U, \text{for each } v \in A^*$;
			\item $h_U(\varepsilon) = \varepsilon$;
			\item $h_U(va) = h_U(h_U(v)a), \text{ for each } (v, a) \in A^* \times A$.
		\end{enumerate}
	\end{lem}
	\begin{proof}
		前两个性质是显然的，关键是第三个。这也是为什么$Dictionary-matching problem$可以配合使用failure function的原因。
		显然$h_U(va) \in \Suff(va), h_U(v)a \in \Suff(va)$，进而其中之一必是另一个的后缀。因此，可以分两种情况讨论：
		\begin{enumerate}[(1)]
			\item $h_U(v)a$是$h_U(va), h_U(va) \neq \varepsilon$的后缀。
			
			不妨令$wa = h_U(va), w \in Pref(U)$，因此，$h_U(v)$是$w$的后缀，
			而由$|h_U(v)| > |w|$，因此，$w$又是$h_U(v)$的后缀，两者矛盾，显然这种情况不成立。
			% 其实这从另一个角度证明了$|h_U(v)a| \ge |h_U(va)|$的。
			
			\item $h_U(va)$是$h_U(v)a$的后缀。
			
			$h_U(va) \in Pref(U), h_U \in \Suff(h_U(v)a)$，应用$h_U$的定义可知。
			$|h_U(va)| \le |h_U(h_U(v)a)|$，因此$h_U(va)$必定是$h_U(h_U(v)a)$的后缀。
			而$h_U(h_U(v)a) \in Pref(U), h_U(h_U(v)a) \in \Suff(va)$，再次应用$h_U$的定义可知。
			$|h_U(va)| \ge |h_U(h_U(v)a)|$，因此，当且仅当$h_U(va) = h_U(h_U(v)a)$ 成立时，才满足条件。
			% 条件三是不是和kmp的next数组的使用很像，这个定理还是挺重要的。
			
		\end{enumerate}
	\end{proof}

	这个定理$(3)$还是挺重要的，这也从侧面证明了为什么$\delta(p,a)=h_X(pa)$。
	\begin{proof}
		$p = h_X(v_1v_2 \cdots v_p), \delta(p, a) = h_X(h_X(v_1v_2 \cdots v_p)a) = h_X(v_1v_2 \cdot v_p a)=h_X(pa)$
	\end{proof}
	
\subsection{线性dictionary-matching automata的建立}
	
	为了基于failure function的自动机$D(x)$，引入$f_U(u)$（其实就是$h_U(u)$）。
	\begin{lem}
		令$U \subseteq A^*$. $\forall (u,a) \in Pref(U) \times A$，可得
		\[
			h_U(ua) =
			\left\{
				\begin{aligned}
					&ua, &\text{ if } ua \in Pref(U),  \\
					&h_U(f_U(u)a), &\text{ if } u \neq \varepsilon \text{ and } ua \notin Pref(U), \\
					&\varepsilon, &\text{ otherwise }.
				\end{aligned}
			\right .
		\]
	\end{lem}
	这其实就是对$h_U(va) = h_U(h_U(v)a)$的详细讨论，分三种情况进行，证明还是挺容易的，此处略过。
	进而，我们定义函数$\gamma_X$对应于情况1，$f_X$对应于$f_X(u)$。从而$(\gamma_X, f_X)$就构成了$DFA$的转换函数。
	
	再回到$DFA$的定义$\Big( Pref(X), \varepsilon, Pref(X) \cap A^*X, \{(p,a,h_X(pa) | p \in Pref(X), a \in A\} \Big)$
	其实就是$\Big( Pref(X), \varepsilon, X, f_X \cap \gamma_X \Big)$。
	由于这里的所有状态都是一个前缀，因此使用$trie$(information retrieval)可以表示$X$的所有前缀。
	
    \begin{codebox}
    \Procname{$\proc{Trie}(X)$}
    \zi \Comment let $\delta$ be the transition function of $(Q, i, T, E)$
    \li $(Q, T, E) \gets ({\O}, {\O}, {\O})$
    \li $i \gets \proc{State-Creation}()$
    \li	\For x \kw{in} word(X)
    \li     \Do
                $t \gets i$
    \li         \For $j \gets 1$ \To $\attrib{x}{length}$
    \li             \Do
                        $q \gets \delta(t, x[j])$
    \li                 \If $q \isequal \const{nil}$
    \li                     \Then
                                $q \gets \proc{State-Creation}()$
    \li                         $E \gets E + \{(t, x[j], q)\}$
                            \End
    \li                 $t \gets q$
                    \End
    \li         $T \gets T + \{t\}$
            \End
    \li \Return $(Q, i, T, E)$
    \end{codebox}
	
	\begin{lem}
		不妨令$U \subseteq A^*$，$\forall (u,a) \in Pref(U) \times A$，如下等式成立：
		\[
			f_U(ua) =
			\left\{
				\begin{aligned}
					&h_U(f_U(u)a), &\text{ if } u \neq \varepsilon,
					&\varepsilon, &\text{ otherwise }.
				\end{aligned}
			\right .
		\]
	\end{lem}
	\begin{proof}
		把之前的定理整理归并一下就好了，证略。
	\end{proof}
	
	%
	% 下面这个伪代码有错误！！！！！！！
	%
	构建好$trie$可以得到线性时间的搜索匹配算法。
	% \begin{lstlisting}[frame=shadowbox,framexleftmargin=5mm,rulesepcolor=\color{gray},numbers=none]
		% LinearDictionaryMatchingAutomata(X)
			% let \gamma be the transition of (Q, i, T, E')
			% let \delta be the transition of (Q, i, T, E)
			% (Q, i, T, E') \leftarrow Trie(X)
			% F[i] \leftarrow NIL
			% \vartheta \leftarrow EmtpyQueue
			% EnQueue(\vartheta, i)
			% while not QueueIsEmpty(\vartheta)
				% loop p \leftarrow DeQueue(\vartheta)
					% for each letter a such that \gamma(p, a) \neq NIL
						% loop q \leftarrow \gamma(p, a)
							% F[q] \leftarrow \delta(F[p], a)
							% // \delta \equiv FailureFunction-Transition
							% if F[q] is in T
							% // obviously, if q is in T, then append q into T, F[q] has checked already.
								% then T \leftarrow T + {q}
							% EnQueue(\vartheta, q)
			% return (Q, i, T, (\gamma, F))
	% \end{lstlisting}
    \begin{codebox}
    \Procname{$LinearDictionaryMatchingAutomata$(X)}
	\zi	\Comment let $\gamma$ be the transition of $(Q, i, T, E')$
	\zi \Comment let $\delta$ be the transition of $(Q, i, T, E)$
	\li $(Q, i, T, E') \gets \proc{Trie}(X)$
	\li $F[i] \gets \const{nil}$
	\li $\vartheta \gets \const{EmptyQueue}$
	\li $\func{EnQueue}(\vartheta, i)$
	\li \While \kw{not} $\func{QueueIsEmpty}(\vartheta)$
	\li		\Do
				$p \gets \func{DeQueue}(\vartheta)$
	\li			\For a such that $\gamma \neq \const{nil}$
	\li				\Do
						$q \gets \gamma(p, a)$
	\li					$F[q] \gets \delta(F[p], a)$
	\li					\Comment $\delta \equiv \proc{FailureFunction-Transition}$
	\li					\If F[q] \kw{in} T
	\li					\Comment obviously, \If q \kw{in} T, then append q into T, F[q] has checked already.
	\li						\Then $T \gets T + \{q\}$
							\End
	\li					$\proc{EnQueue}(\vartheta, q)$
					\End
			\End
	\li \Return $(Q, i, T, (\gamma, F))$
    \end{codebox}

	\begin{lem}
		\proc{LinearDictionaryMatchingAutomata}表示基于$X$的dictionary-matching自动机$D(X)$ 的建立过程，
		时间复杂度为$O(|X|\times|A|)$，空间复杂度为$O(|X|\times|A|)$。
	\end{lem}
	
	这块儿稍微难以理解的是这个均摊。显然$trie$上共有$O(|X|)$个结点，
	这也就意味着有$O(|X|)$个元素出队，然而内层循环$FailureFunction-Tranision$的时间复杂度也是$O(|X|)$。
	那么，总的时间复杂度为什么不是$O(|X|\times|X|)$?
	\begin{proof}
		显然只有满足均摊条件才会这样，那么到底哪里存在均摊呢？
		考虑$\gamma(p,a) = q, r = \delta(F[p], a)$，那么一定有$|r| \le |q|$。
		那么，假如$\gamma(r,a) \neq NIL$，$r$的这次内层循环至多$|r|$次，而$p$的这次循环至多$|p|-|r|$。
		因此，不妨假设$\forall a \in A, \gamma(p,a) \neq NIL$，
		那么从$trie$的每个叶子$p_{leaf}$结点开始，
		沿着failure function经过的结点不断的查询$\forall a \in A$的$\delta$转换函数，
		这多总共进行$|p_{leaf}|$次，因此，$trie$上所有结点的内层循环总共进行不超过$|X| \times |A|$次。
		故内层循环的均摊时间复杂度为$O(|A|)$，从而得到整体的时间复杂度为$O(|X|\times|A|)$。
	\end{proof}
	
	\begin{lem}
		不妨令$U \subseteq A^*$, $\forall (u,a) \in Pref(U) \times A$, 下列等式成立：
		\[
			f_U(ua) =
			\left\{
				\begin{aligned}
					&f_U(u)a, 		&\text{ if } u \neq \varepsilon \text{ and } ua \in Pref(U),       \\
					&f_U(f_U(u)a), 	&\text{ if } u \neq \varepsilon \text{ and } ua \notin Pref(U),    \\
					&\varepsilon,	&\text{ otherwise }.
				\end{aligned}
			\right .
		\]
	\end{lem}
	
\subsection{线性dictionary-matching automata的搜索}

	\begin{thm}
	\label{thm:ac_automata_complex}
		$X$表示有限单词的集合，$y$表示一个字符串，
		$\ell$表示$\forall x \in X$的最大长度，$d$表示$trie$的最大出度，
		使用基于$X$的$DFA$搜索$X$中的字符串在$y$中匹配的位置，
		可以在时间复杂度$O(|y| \times d)$和空间复杂度$O(\ell \times \log d)$内实现。
	\end{thm}
	\begin{proof}
		时间复杂度还是采用前面的均摊方法，此处证略。
		% 均摊还是会挺不好理解的，后面可以补上。
	\end{proof}
	
	更泛化的做，对于给定有限语言$X$和failure函数$f_X$，
	自动机$D(X)$可以使用另一个failure函数$\hat{f_X}$进行优化。
	引入$Follow_U(u)$表示$\forall u \in Pref(U)$的下一个字符：
	\[
		Follow_U(u) = \{a | a \in A, u \in Pref(U), ua \in Pref(U) \}
	\]
	进一步可以得到$\hat{f_X}$的递推式：
	\begin{lem}
		\[
			\hat{f_X(p)} =
			\left\{
				\begin{aligned}
					&f_X(p),			&\text{ if } p \neq \varepsilon \text{ and } Follow_X(f_X(p)) \nsubseteq Follow_X(p),   \\
					&\hat{f_X(f_X(p))},	&\text{ if } p \neq \varepsilon \text{ and } Follow_X(f_X(p)) \subseteq Follow_X(p),    \\
					&NIL,				&\text{ otherwise }.
				\end{aligned}
			\right .
		\]
	\end{lem}
	做这个优化可以考虑对$|A|$进行状态压缩，然后用位运算实现集合的关系。
	但实际上最坏情况下的时间复杂度与不使用$\hat{f_X}$是一样的，并没有任何卵用。
	
\section{Matching words}

\subsection{前言}	
	
	% String-matching problem
	\begin{prob}
		（字符串匹配问题）给定一个单词$x$，找到$x$在$y$上出现的所有位置。
	\end{prob}
	其实可以把这个问题看成仅包含一个单词的字典匹配问题，同时这其实也是经典算法KMP需要解决的问题。
	
	\begin{thm}
		\Emph{(Knuth, Morris, and Pratt, 1977).}
		基于模式串$x$和目标串$y$的字符串匹配问题可以在时间复杂度$O(|x|+|y|)$和空间复杂度$O(|x|)$内实现，
		最坏情况下$delay$的时间复杂度是$\Theta(log|x|)$。
	\end{thm}
	为了讨论字符串匹配问题的时间复杂度，
	不得不引入Knuth, Morris和Pratt有关在$trie$上搜索$delay$的边界
	$\left\lfloor \log_{\o}(|x|+1) \right\rfloor$，这里${\o} = (1+\sqrt5)/2$（黄金分割点）。
	
	\begin{mthm}
		基于模式串$x$和目标串$y$的字符串匹配问题可以按照如下步骤解决：
		\begin{itemize}
			\item 构建基于$x$的自动机$M(A^*x)$可以在时间复杂度$O(|x|)$和空间复杂度$O(|x|)$内实现；
			\item 使用$y$进行搜索的时间复杂度为$O(|y|)$，空间复杂度为$O(\log \min \{ 1+\left\lfloor \log_2|x| \right\rfloor, |A| \})$。
		\end{itemize}
	\end{mthm}
	\begin{thm}
		\Emph{(Galil and Seiferas, 1983).}
		基于预先存储的$x$和$y$的字符串匹配问题可以在时间复杂度$O(|x|+|y|)$和空间复杂度$O(1)$内实现。
	\end{thm}
	
\subsection{String-matching automata}

	因为字符串匹配问题可以看成特殊的字典匹配问题，从而可以使用相似的方式对字符串匹配对应的自动机进行形式化定义
	\[
		\Big( Pref(x), \varepsilon, \{x\}, \{(p, a, h_x(pa)) | p \in Pref(x), a \in A \} \Big)
	\]
	由于字符串匹配问题的特殊性，可以再用增量法构建满足上式的自动机（增量法还是经常得到应用的）。
	引入助记符$border$，当$v \in Pref(u) \cap \Suff(u)$成立时，我们称$v$是$u$的$border$。
	使用$Bord(u)$表示非空字符$u$的最长$border$。通过引入$border$，我们可以重写$h_x$的等式：
	\[
		\forall (p,a) \in Pref(x) \times A, h_x(pa) =
		\left\{
			\begin{aligned}
				&pa, 		&\text{ if } pa \in Pref(x),	\\
				&Bord(pa),	&\text{ otherwise }
			\end{aligned}
		\right .
	\]
	自动机$M(A^*x)$的在线建立，可以依据如下引理：
	\begin{lem}
		$\forall u \in A^*$，不妨令$E_u$表示$M(A^*u)$上的边集，我们有：
		\[
			E_\varepsilon = \{ (\varepsilon, b, \varepsilon) | b \in A \}.
		\]
		此外，$\forall (u,a) \in A^* \times A$，我们有：
		\resetcounter
		\begin{align}
			E_{ua} 	&= E_{ua}' \cup E_{ua}''		\\
			E_{ua}' &= \big( E_u \setminus \{(u,a,h_u(ua))\} \big) \cup {(u, a, ua)}	\\
			E_{ua}''&= \{ (ua,b,w) | (h_u(ua), b, w) \in E_{ua}' \}
		\end{align}
	\end{lem}
	\begin{proof}
		显然$E_\varepsilon$满足上式。
		
		不妨令$u \in A^*, a \in A, v = h_u(ua)$.
		当满足$\forall (p,b), p \in Pref(u), b \in A, |p|<|u|$时，
		$\delta(p,b) \in E_u$显然成立，又因为$|p| < |u|, p \neq u$，故$\delta(p,b) \neq \delta(u,a)$。
		因此$\delta(p,b) \in E_{ua}'$。而$\delta(u,a) = ua \in E_{ua}‘$显然成立。
		
		因此仅需证明$\delta(ua,b) \in E_{ua}''$，即等式$E_{ua}'' = \{ (ua,b,w) | (h_u(ua), b, w) \in E_{ua}' \}$。\\
		即证$\forall b \in A$, $\delta(v,b)=w,\delta(ua,b)=w' \in E_{ua}$并且$w = w'$。
		因为$w,w' \in Pref(ua)$，故仅需证明$|w| = |w'|$。
		
		$v = h_u(ua) \le |ua|$，回想failure function的转移函数$h_u(ua)$表示的状态一定在$ua$表示状态的failure路径上，
		因此，我们有$|w| \le |w'|$，从而进行如下推导
		\begin{align*}
			|w| \le |w'|, |w'| \le |vb| 	&\Rightarrow 	|w| \le |vb|			\\
			v = Bord(ua)					&\Rightarrow	v \in Pref(ua), v \in \Suff(ua)	\\
			v \in \Suff(ua) 					&\Rightarrow 	vb \in \Suff(uab)	\\
			w' = Bord(uab) 				&\Rightarrow 	w' \in Pref(uab), w' \in \Suff(uab)	\\
			vb \in \Suff(uab), w' \in \Suff(uab), |w'| \le |vb| &\Rightarrow w' \in \Suff(vb)	\\
			|w'| < |uab|, w' \in Pref(uab)	&\Rightarrow	w' \in Pref(ua)		\\
			v \in Pref(ua), w' \in Pref(ua), |w'| \le |vb|	&\Rightarrow w' \in Pref(vb)	\\
			w' \in \Suff(vb), w' \in Pref(vb) &\Rightarrow 	w' \in border(vb)	\\
			w = Bord(vb), w' \in border(vb) &\Rightarrow 	|w| \ge |w'|	\\
			|w|\le|w'|, |w|\ge|w'|			&\Rightarrow 	|w| = |w'|
		\end{align*}
		从而我们知道$w \equiv w'$。	
	\end{proof}
	上式恰恰说明了如何使用增量法由自动机$(Pref(u), i, {u}, E_u)$得到新的自动机$(Pref(ua), i, {ua}, E_{ua})$。
	即增加一个新的状态表示前缀$ua$，保留一部分转换函数的边并新增加一些边。显然，整个构建过程是在线进行的。
	其实，这也是SAM使用增量构法建自动机的基本思路。基于邻接矩阵的自动机的构建过程的伪代码如下：
	\begin{codebox}
	\Procname{$\proc{StringMatchingAutomata}(x)$}
	\zi \Comment $\delta$ be the transition function of $(Q, i, {\o}, E)$
	\li	$(Q, E) \gets {{\O}, {\O}}$
	\li $i \gets \proc{State-Creation}()$
	\li \For b \kw{in} A
	\li		\Do $E \gets E + \{(i, b, i)\}$
			\End
	\li $t \gets i$
	\li \For $j \gets 1$ \To \attrib{x}{length}
	\li		\Do
				$r \gets \delta(t, x[j])$
	\li			$q \gets \proc{State-Creation}()$
	\li			$E \gets E - \{(t, x[j], r)\} + \{(t, x[j], q)\}$
	\li			\For b \kw{in} A
	\li				\Do $E \gets E + \{(q, b, \delta(r, b))\}$
					\End
	\li			$t \gets q$
			\End
	\li \Return $(Q, i, \{t\}, E)$
	\end{codebox}
	
\subsection{线性string-matching automata}
	
	那么到底如实使用增量法建立一个基于邻接表并且时间和空间复杂度都是线性的自动机呢？
	
	这里有个概念，\Emph{关键边（significant edges）}。
	若满足$\delta(p,a)=q, q \neq \varepsilon \text{ and }q \neq \const{nil}$，我们称这样的边是关键边。
	如果一条边是关键边，当$q=pa$时我们称这样的边为\Emph{前向边（forward）}，否则我们称为\Emph{后向边（backward）}。
	
	\begin{prop}
		基于任意字符串$x$的string-matching自动机的关键便的上界为$2|x|$；
		更确切的说，前向边的数量恰好为$|x|$，后向边的数量的上界为$O(|x|)$。
		（当$x$的第一个字符仅仅出现在$x$的开始位置时，达到边界。）
		% 这个边界很奇特？？？
	\end{prop}
	为了证明上述命题，提出如下引理：
	\begin{lem}
		$(p,a,q)$和$(p',a',q')$表示字符串$u$的string-matching自动机的两条不同的后向边，那么必有
		$|p| - |q| \neq |p'| - |q'|$。
	\end{lem}
	这个引理很特殊，刚看到觉得挺费解的，需要简单证明一下。
	\begin{proof}
		使用反证法，即$\exists (p,a,q),(p',a',q') \in E$并且$|p|-|q| = |p'|-|q'|$。
		
		若$|p|=|p'|$，又$p \in Pref(u), p' \in Pref(u)$，因此，$p = p'$，同理$q = q'$。
		由于这是两条关键边，则一定有$a=a'$，与两边不同相矛盾。
		
		若$|p| \neq |p'|$，不失一般性，我们令$|p| > |p'|$，故$|q| > |q'|$，故有如下推导
		\begin{align*}
			q = Bord(pa)	&\Rightarrow q \in Pref(pa), q \in \Suff(pa)	\\
			qa^{-1} \in Pref(p), qa^{-1} \in \Suff(p)	&\Rightarrow qa^{-1} \in border(p)	\\
			q \in Pref(u), q' \in Pref(u), |q|>|q'| &\Rightarrow q' \in Pref(q)	\\
			a' = u_{|q'|} = u_{|q'|+|p|+1-|q|}, |p'|=|p|-|q|+|q'| &\Rightarrow a' = u_{|p'|+1}	\\
			\because q' = Bord(p'a') &\Rightarrow |q'|=|p'|+1
		\end{align*}
		显然$(p',a',q')$是一条前向边，与条件矛盾。
		
		综上可知，结论成立。
	\end{proof}
	这个结论证明了对于后向前$|p|-|q|$互不相等，又因为取值在$[1,|x|]$区间内，故后向边的上界一定为$O(|x|)$。
	而前向边恰好为$(|x|)$更好理解，因为从$\varepsilon \leftarrow p_{x}$恰好是包含所有的前向边，即字符串$x$本身。
	
	因此，基于邻接表并只建立关键边的string-matching自动机的建立过程如下：
    \begin{codebox}
	\Procname{$\proc{LinearStringMatchingAutomata}(x)$}
		\zi	\Comment let $\delta$ be the transition function of $(Q, i, {\O}, G)$
		\li $Q \gets {\O}$
		\li $i \gets \proc{State-Creation}()$
		\li $G[i] \gets {\O}$
		\li $t \gets i$
		\li \For $j \gets 1$ \To $x$
		\li		\Do
					$r \gets \delta(t, x[j])$
		\li			$q \gets \proc{State-Creation}()$
		\li			\If $r \neq i$
		\li				\Then $G[t] \gets G[t] - \{(x[j], r)\}$
						\End
		\li			$G[t] \gets G[t] + \{(x[j], q)\}$
		\li			$G[q] \gets G[r]$
		\li			$t \gets q$
				\End
		\li \Return $(Q, i, \{t\}, G)$
	\end{codebox}
	
	显然上述建立自动机$M(A^*x)$的空间复杂度为$O(|x|)$，时间复杂度为$O(|x| \times |A|)$。
	
\subsection{string-matching自动机的性质}

	给定一个单词$u$，使用$se_u(p)$表示string-matching状态机的状态$p$的关键边的数量。
	若$p \in Pref(u), q \in Pref(p)$，$se_u(p,q)$表示从$u$的前缀的$q$到$p$的关键边的集合。
	\[
		se_u(p,q) = se_u(q) + se_u(q \cdot p_{|q|+1}) + \cdots + se_u(q \cdot p_{|q|+1} \cdots p_{|p|-1}) + se_u(p).
	\]
	\begin{lem}
		不妨令$(u,a) \in A^* \times A$，$\forall v \in Pref(ua)$，有
		\[
			se_{ua}(v) =
			\left\{
				\begin{aligned}
					&se_u(Bord(ua)),	&\text{ if } v = ua,	\\
					&se_u(u) + \chi(Bord(ua) = \varepsilon),	&\text{ if } v = u,	\\
					&se_u(v),			&\text{ otherwise }.
				\end{aligned}
			\right .
		\]
	\end{lem}
	\begin{proof}
		$se_u(p)$表示的是数量，所以这个性质还是挺显然的，证略。
	\end{proof}
	
	\begin{lem}
		不妨令$u \in A^+$，$\forall v \in Pref(u)$，有
		\[
			se_u(v) =
			\left\{
				\begin{aligned}
					&se_u(Bord(u)),		&\text{ if } v = u, \\
					&se_u(Bord(v)) + \chi(Bord(va) = \varepsilon),	&\text{ if } va \in Pref(u), a \in A,	\\
					&1,					&\text{ if } v = \varepsilon.
				\end{aligned}
			\right .
		\]
	\end{lem}
	\begin{proof}
		这个其实等价于前面的性质，证略。
	\end{proof}
	
	\begin{lem}
		不妨令$u \in A^+$, $\forall v \in Pref(u) \setminus \{\varepsilon\}$，有
		\[
			2|Bord(v)| \ge |v| \Rightarrow se_u(Bord(v)) = se_u(Bord^2(v)).
		\]
	\end{lem}
	\begin{proof}
		当$v=u$时，结论显然成立；
		
		当$v \neq u$时，
		不妨令$k = 2|Bord(v)| - |v|, k\ge0, |Bord(v)|=l$，这个可以想象成两个$Bord(v)$形成$v$，形如
		\[
			\begin{matrix}
				v_1 & v_2 & v_3  & \cdots & v_{l-k+1} & v_{l-k+2} & v_{l-k+3} & \cdots & v_l  &  \\
					&     &      &        & v_1       & v_2       & v_3       & \cdots & v_k  & \cdots \ v_l
			\end{matrix}
		\]
		因此$k$其实就是重叠部分的长度，不妨令$w = v_1v_2v_3 \cdots v_k, a = v_{k+1}$，那么$wa \in border(Bord(v)a)$。
		
		不妨令$v' = Bord(v), wa \in border(v'a), v'a \in Pref(u)$，\\
		从而$Bord(v'a) \ge |wa| = k+1$，
		显然$Bord(v'a)=Bord^2(va) \neq \varepsilon$，故此时条件亦成立。
		
		综上所述，证毕。
	\end{proof}
	
	\begin{prop}
		$u \in A^*, \forall p \in Q_{M(A^*u)}$，有结论
		\[
			se_u(p) \le 1 + \left\lfloor \log_2(|p|+1) \right\lfloor
		\]
	\end{prop}
	\begin{proof}
		当$|p|=0$时，结论显然成立。
		
		对$|p|\le1$，采用数学归纳法进行证明。不妨引入$j$，满足
		\[
			2^j \le |p| + 1 < 2^{j+1}
		\]
		继续引入$k$，满足
		\[
			|Bord^{k+1}(p)|+1 < 2^j \le |Bord^k(p)|+1
		\]
		因此$\forall l \in [0, k-1]$，有
		\[
			2|Bord^{l+1}(p)| \ge 2 \times (2^j-1) = 2^{j+1}-2 \ge |p| \ge |Bord^l(p)|
		\]
		由前面的引理可知$se_u(Bord^{l+1}(p)) = se_u(Bord^{l+2}(p))$，由于$l \in [0,k-1]$，从而
		\[
			se_u(Bord(p)) = se_u(Bord^{k+1}(p))
		\]
		因为$|Bord^{k+1}(p)| < |p|$，故由数学归纳法假设可知
		\begin{align*}
			&\quad\ \  	se_u(Bord^{k+1}(p)) \le 1 + \left\lfloor \log_2(|Bord^{k+1}(p)|+1) \right\rfloor	\\
			&\Rightarrow 	se_u(Bord^{k+1}(p)) < 1 + \left\lfloor \log_2(2^j) \right\rfloor					\\
			&\Rightarrow	se_u(Bord(p))		< 1 + j	\\
			&\Rightarrow	se_u(Bord(p))		\le j
		\end{align*}
		又因为$se_u(p) \le se_u(Bord(p)) + 1$，从而有$se_u(p) \le j+1$。
		
		综上所示，结论成立。
		
	\end{proof}
	\begin{prop}
		$\forall u \in A^*$, 对于$M(A^*x)$的所有后向边或者空边，有
		\[
			se_u(p, q) \le 2|p| - 2|q| + 2 - \chi(p=u) - \chi(q=\varepsilon)
		\]
	\end{prop}
	\begin{proof}
		采用数学归纳法结合上面几个引理可证，证略。
		% 没看出有什么用
	\end{proof}
	
\subsection{线性string-matching自动机的搜索}

	考虑基于字符串$x$的线性string-matching自动机执行$Matcher$函数。
	对于自动机的每条后向边或者空边，使用$c_x(p,q)$表示从状态$q$经过状态$p$再回到状态$q$的变化时间。
	例如，从状态$q$开始接受字符序列$x_{|q|+1}, x_{|q|+2}, \cdots, x_{|p|}, a$。
	使用$C_x(y)$表示在基于字符串$x$的自动机上搜索字符串$y$所用时间。
	
	\begin{lem}
		$\forall x,y \in A^*$，
		自动机$M(A^*x)$存在有限的后向边或空边$(p_j, a_j, q_j)_{1 \le j \le k}$满足如下三个条件：
		\begin{enumerate}[i]
			\item $q_k = \varepsilon$;
			\item $\sum_{j=1}^{k}(|p_j|-|q_j|+1) = |y|$;
			\item $C_x(y) \le \sum_{j=1}^{k} c_x(p_j, q_j)$.
		\end{enumerate}
	\end{lem}
	\begin{proof}
		显然当$|y| = 0$时，结论成立。
		
		当$|y| \ge 1$时，采用数学归纳法进行证明。
		考虑条件$(i)$什么情况下成立，即当$y_|y| \notin \{x_i | i \in [1,|x|]\}$，
		即$y$的最后一个不在$x$中出现，显然，存在且有限。
		
		由于$(p_l)_{0 \le l \le y}$表示状态$p$代表的$x$的前缀，即$p_l = h_x(y_1y_2 \cdots y_l)$。
		不妨令$m, 0 \le m \le |y|-1, m' \le m$是满足$p_{m+1} = p_{m'}$的最小$m$，注意这里$m$必须是最小的。
		因此，$(p_m, y_{m+1}, p_{m'})$一定是后向边或者空边。
		并且从状态$p_{m'}$经过状态$p_{m}$再返回状态$p_{m'}$一定经过长为$m-m'+1$的字符序列
		$y_{m'+1}, y_{m'+2}, \cdots, y_{m}, y_{m+1}$。
		
		故不妨令$y' = y_1y_2 \cdots y_{m'} \cdot y_{m+2} y_{m+3} \cdots y_{|y|}$，即从$y$中截取上述$m-m'+1$的字符序列。
		显然有$C_x(y) \le C_x(y') + c_x(p_{m}, p_{m'})$，而$|y'| < |y|$。
		由数学归纳法可知
		\[
			m\text{最小的反向边} \Rightarrow |y| = |y'| + m - m'+1 = |y'| + (|p_m|-|p_{m'}|+1)	
        \]
        \[
			\sum_{j=1}^{k} (|p'_j|-|q'_j|+1) = |y'| \Rightarrow  |y| = \sum_{j=1}^{k} (|p_j|-|q_j|+1)	
        \]
        \[
			C_x(y) \le C_x(y') + c_x(p_{m}, p_{m'}), C_x(y') \le \sum_{j=1}^{k} c_x(p'_j, q'_j) \Rightarrow C_x(y) \le \sum_{j=1}^{k} c_x(p_j, q_j)
		\]
		其实都是在$y'$的基础上增加一条后向边$(p_m, y_{m+1}, p_{m'})$。

        综上三个结论均成立。
	\end{proof}
	
	\begin{thm}
		使用线性string-matching自动机可以在时间复杂度$O(y)$和空间复杂度$O(1)$内，解决$x$和$y$的字符串匹配问题。
		$delay$的时间复杂度为$O(\log \min \{1 + \left\lfloor \log_2|x| \right\rfloor, |A| \})$。
	\end{thm}
	\begin{proof}
		无论实现一个多么高效的邻接表，我们都可以认为从当前状态转换到下一状态的时间渐进线性于当前状态的关键出边的总数。
		从而对于后向边或空边$(p,a,q)$，有
		\[
			c_x(p, q) = O(se_x(p, q))
		\]
		由上述引理可知
		\[
			c_x(p, q) = O(|p|-|q|+1)
		\]
		从而我们知道总的时间复杂度为$O(|y|)$。
		
		由前面的引理，我们知道任何一个邻接表的大小的上界为$O(\min\{1+\left\lfloor \log_2|x| \right\rfloor, |A|\})$。
		进而，我们构建线性自动机时，可以将邻接表结点维护成一棵平衡树。从而说明自动机的状态时间可以在$\log$级别内实现，
		从而证明了$delay$的时间上界。
	\end{proof}
	上面的平衡树是个好思路，因为树不会特别高$\log_2|A|$，这样搜素还是很快的，关键是节省了大量的空间。
	
	上面的模型都是基于字符是有序的、可比较的前提，下面我们假设若字符是无序的。
	对于给定的字符串$x$，使用$S(x)$表示搜索阶段是在线进行并且字符增量大小为1的字符串匹配算法的集合。
	字符串匹配算法本身是基于字符比较的，否则如何谈比较？那么这里如何处理，可以使用出现过的字符频度等进行比较。
	使用$L(x)$表示使用线性string-matching自动机搜索模式串$x$在目标串$y$上出现次数的算法。
	
	\begin{thm}
		$\forall x \in A^+, |y| = n > 0$，考虑算法$\lambda \in L(x)$，
		在比较模型中$\lambda$进行不超过$2n-1$次字符比较，
		其中每个字符进行不超过$\min \{1+\left\lfloor \log_2|x| \right\rfloor, |A| \}$ 次比较。
	\end{thm}
	\begin{proof}
		每个字符进行不超过$\min \{1+\left\lfloor \log_2|x| \right\rfloor, |A| \}$次比较这是显然的，
		因为对于$\forall p \in Q_{A^*x}$，这就是关键出边的上界。
		然而，总的比较次数$2n-1$中的$-1$恰恰是$\exists (p_j,a_j,p_k), p_k=\varepsilon$。
		% 其实我还是不懂为什么有空边上界就不是$2n$ ?
	\end{proof}
	
	\begin{thm}
		$\forall x \in A^+, |y| = n > 0$，考虑算法$\lambda \in L(x)$采用如下策略：
		当从状态$p$进行状态转换时，最后查询状态$p$的前向出边。
		那么，在比较模型中$\lambda$进行不超过$\left\lfloor (2 - 1 / |x|) \times n \right\rfloor$次比较。
	\end{thm}
	\begin{proof}
		不妨令$(p, a, q)$表示自动机$M(A^*x)$的后向边或者空边，因此，
		从状态$q$经过状态$p$后返回状态$q$的比较上界为$se_x(p,q) - \chi(q \neq x)$，
		使用命题$se_u(p, q) \le 2|p| - 2|q| + 2 - \chi(p=u) - \chi(q=\varepsilon)$，
		代入有上界为$(2 - 1 / |x|) \times (|p| - |q| + 1)$。
		因此，上界为$(2 - 1 / |x|) \times n$。
	\end{proof}
	这可以对于给定长度$m$的模式串，在搜索过程中$delay$的界为
	$\min \{1+\left\lfloor \log_2|x| \right\rfloor, |A| \}$， 系数$2-1 / m$。
	
	\begin{prop}
		$\forall m \ge 1, n \ge m$，在比较模型中，$\exists x \in A^m, y \in A^n$
		满足$S(x)$中的任何算法在最坏情况下执行至少$\min \{1+\left\lfloor \log_2|x| \right\rfloor, |A| \}$次字符比较。
	\end{prop}
	\begin{proof}
		定义递归的映射函数$\xi : A^* \leftarrow A^*$：
		\[
			\forall (u,a) \in A^* \times A, \xi(ua) = \xi(u) \cdot a \cdot \xi(u), \xi(\varepsilon) = \varepsilon
		\]
		比如$\xi(abcd) = abacabadabacaba$，显然是个回文串。
		
		令$k = \min\{1 + \left\lfloor \log_2 m \right\rfloor, |A|\}$，选择$k$个不同的字符$a_1, a_2, \cdots, a_k$，
		并且假定$\xi(a_1 a_2 \cdots a_{k-1})a_k \in Pref(x)$，
		若$\xi(a_1 a_2 \cdots a_{k-1})$已经是$y$的前缀，
		可知$x$的匹配起始位置一定满足$2^{k-\ell}, 1 \le \ell \le k$。
		故最坏情况下在$2^{k-1}$位置上算法至少进行$k$个字符的比较。
	\end{proof}
	
	\begin{prop}
		$\forall m \ge 1, n \ge 0$，在比较模型中，$\exists x \in A^m, y \in A^n$
		满足$S(x)$中的任何算法在最坏情况下执行至少$\left\lfloor (2 - 1 / |m|) \times n \right\rfloor$次字符比较。
	\end{prop}
	\begin{proof}
		不妨假定$x = ab^{m-1}, y \in Pref((a{a,b}^{m-1})^*), j \in [1, n]$，
		$v$是$y_1 y_2 \cdots y_{j-1}$的最长后缀同时也是$x$的前缀。
		
		若$v \neq \varepsilon$，为了能够检测$x$在位置$j$或$j-|v|$一定要查询$y_j=a$和$y_j=b$，
		而这恰恰是最坏情况；若$v = \varepsilon$，算法可以仅仅查询$y_j = a$。
		但是根据$y$的定义，$v=\varepsilon$仅仅发生在$j \equiv 1 (\mod m)$。
		从而，比较的字符次数不会超过$2n - \left\lceil n / m \right\rceil = \left\lfloor (2 - 1 / m) \right\rfloor$。
        % 虽然不是特别懂，但是大概知道在干嘛，关键问题是$x$和$y$的构造
	\end{proof}

\section{Suffix automata}

\subsection{前言}

	字符串$x$的后缀自动机是一种能够识别所有$x$后缀的确定化、最小化的自动机。可以将其表示为$M(\Suff(x))$。
	一个后缀自动机的例子如下图所示：
	后缀自动机$M(\Suff(x))$可以使用$x$的下标解决如下问题：
	\begin{prob}
		\Emph{(Index Problem.)} 给定字符串$x$，对它进行预处理使得能够识别$x$的所有子串。
	\end{prob}
	这个问题的另一种可行解是构建基于$x$后缀集合的$trie$树，通过对给定字符串$x$进行旋转也会得到一个空间高效的解。
	
	然而后缀自动机的优势在于它的空间复杂度是线性的，尽管子串的数量近似于字符串长度的平方。
	并且这个自动机的构造过程也是线性的。
	
	\begin{mthm}
		基于字符串$x$的后缀自动机的空间复杂度是$O(|x|)$的，
		并可以在时间复杂度$O(|x| \times |A|)$内构建。
	\end{mthm}
	
\subsection{后缀自动机的性质}
\label{sub:sam_property}

\subsubsection{End-positions.}
	
	\begin{lem}
	\label{lem:u_in_sufv}
		不妨令$u,v \in A^*$，若$u \in \Suff(v)$，则有$v^{-1} \Suff(x) \subseteq u^{-1} \Suff(x)$.
	\end{lem}
	\begin{proof}
		若$v^{-1} \Suff(x) = {\o}$，那么$v^{-1} \Suff(x) \subseteq u^{-1} \Suff(x)$是显然的。
		
		若$v^{-1} \Suff(x) \neq {\o}$，则不妨令$\forall z \in v^{-1} \Suff(x)$，从而有$vz \in \Suff(x)$，
		因为$u \in \Suff(v)$，则必定有$uz \in \Suff(x) \Rightarrow z \in u^{-1} \Suff(x)$。
		故有
		\[
			u \in \Suff(v) \Rightarrow v^{-1} \Suff(x) \subseteq u^{-1} \Suff(x).
		\]
	\end{proof}
	
	右端上下文满足类似相反的性质，为了形式化定义右端上下文，引入函数$endpos_x: Fact(x) \rightarrow \mathbb{N}$
	\[
		endpos_x(u) = \min \{ |w| | w \in Pref(x) \text{ and } u \in \Suff(w) \}.
	\]
	$endpos_x(u)$表示字符串$u$出现在$x$上的最早位置。
	比如，$x = abcbc, u=bc$，那么$endpos_{abcbc}(bc) = \min \{ |abc|, |abcbc| \} = 3$。
	
	\begin{lem}
	\label{lem:u_equsuf_v}
		不妨令$u,v \in Fact(x)$，当$u \equsuf v$时，必定有结论$endpos_x(u) = endpos_x(v)$。
		同时，等价于$u$和$v$其中之一必定是另一个的后缀。
	\end{lem}
	\begin{proof}
		不妨令$y,z \in A^*$，同时满足$x = yz, endpos_x(u) = |y|$，
		那么$z$一定是$u^{-1} \Suff(x)$集合中最长的一个串。
		（注意，这其实是一个极大-极小定理的简单应用，$z$最大，则证明$y$一定最小，显然这是满足$endpos_x(u)$的定义的）
		由$u \equsuf v$可知，$u^{-1} \Suff(x) = v^{-1} \Suff(x)$，那么$y \in v^{-1} \Suff(x)$，
		并且一定是$v^{-1} \Suff(x)$中长度最长的，否则必定有$|y'| > |y|, y' \in v^{-1} \Suff(x) = u^{-1} \Suff(x)$。
		显然，由$endpos_x$的定义可以知道$endpos_x(u) = endpos_x(v)$。
		那么一定有$u \in \Suff(y), v \in \Suff(y)$。
		显然可知，$u \in \Suff(v)$或者$v \in \Suff(u)$。
	\end{proof}
	
	另一个$\Suff(x)$的常用性质是它的句法同余关系，即它将子串的后缀分割成区间（恰好对应于后缀的长度）。
	% Another often used property of the syntatic congruence associated with \Suff(x) is that is partitions
	% the suffixes of factors into intervals (with respect of the lengths of suffixes).
	% 至今还是不明白这到底是什么意思？
	
	\begin{lem}
	\label{lem:suf_congruence}
		不妨令$u,v,w \in Fact(x)$. 若$u \in \Suff(v), v \in \Suff(w), u \equsuf w$，
		则有$u \equsuf v \equsuf w$.
	\end{lem}
	\begin{proof}
		\begin{align*}
			u \in \Suff(v)		&\Rightarrow 	v^{-1} \Suff(x) \subseteq u^{-1} \Suff(x)	\\
			v \in \Suff(w)		&\Rightarrow	w^{-1} \Suff(x) \subseteq v^{-1} \Suff(x)	\\
			u \equsuf w			&\Rightarrow	u^{-1} \Suff(w) = w^{-1} \Suff(u)
		\end{align*}
		从而我们可知$w^{-1} \Suff(x) = v^{-1} \Suff(v) = w^{-1} \Suff(w)$。
		由$\equsuf$的定义可知，$u \equsuf v \equsuf w$.
	\end{proof}
	
	\begin{cor}	
	\label{cor:3_cond}
		不妨令$u,v \in A^*$，下面三个条件中至少有一个条件成立：
		\begin{enumerate}[(1)]
			\item $u^{-1} \Suff(x) \subseteq v^{-1} \Suff(x)$;
			
			\item $v^{-1} \Suff(x) \subseteq u^{-1} \Suff(x)$;
			
			\item $u^{-1} \Suff(x) \cap v^{-1} \Suff(x) = {\o}$.
		\end{enumerate}
	\end{cor}
	\begin{proof}
		因为三个条件中至少一个成立，故仅仅需要证明当$u^{-1} \Suff(x) \cap v^{-1} \Suff(x) \neq {\o}$时，
		可以得到结论$u^{-1} \Suff(x) \subseteq v^{-1} \Suff(x)$或者$v^{-1} \Suff(x) \subseteq u^{-1} \Suff(x)$。
		
		不妨令$z \in u^{-1} \Suff(x) \cap v^{-1} \Suff(x)$，从而有$uz \in \Suff(x), vz \in \Suff(x)$。
		那么$u \in \Suff(xz^{-1}), v \in \Suff(xz^{-1})$。从而可知$u,v$中的其中一个必定是另一个后缀。
		\begin{align*}	
			u \in \Suff(v)	&\Rightarrow v^{-1} \Suff(x) \in u^{-1} \Suff(x)	\\
			v \in \Suff(u)	&\Rightarrow u^{-1} \Suff(x) \in v^{-1} \Suff(x)
		\end{align*}
	\end{proof}
	这个引理表明$\forall u,v$的右端上下文要么不相交，要么其中一个必是另一个的子集。
	这个推论的成立对后面的$suffix\ function$非常重要。
	
\subsubsection{Suffix function}
	
	\begin{defn}
	\label{defn:sx}
	函数$s_x: Fact(x) \leftarrow Fact(x)$定义如下：
	\[
		\forall v \in Fact(x), s_x(v) = \text{ the longest } u \in \Suff(v) \text{ and } u \neq_{\textit{\Suff(x)}} v.
	\]
	\end{defn}
	由引理~\ref{cor:3_cond}可知，$s_x$的函数定义等价于：
	\[
		\forall v \in Fact(x), s_x(v) = \text{ the longest } u \in \Suff(v) \text{ and } v^{-1} \Suff(x) \subset u^{-1} \Suff(x).
	\]
	函数$s_x$也称为字符串$x$的$suffix\ function$，而引理~\ref{lem:sx_eq}将说明$suffix\ function$与自动机$M(\Suff(x))$中所谓$suffix\ link$ 间的关系。
	
	\begin{lem}
	\label{lem:sx_eq}
		假定$x \neq \varepsilon$，不妨令$u,v \in Fact(x) \setminus \{ \varepsilon \}$。
		若$u \equsuf v$，则结论$s_x(u) = s_x(v)$一定成立。
	\end{lem}
	\begin{proof}
		\begin{align*}
			u,v \in Fact(x)	&\Rightarrow u^{-1} \Suff(x), v^{-1} \Suff(x) \neq {\o}	\\
			u \equsuf v		&\Rightarrow u^{-1} \Suff(x) = v^{-1} \Suff(x)
		\end{align*}
		而由引理~\ref{cor:3_cond}可知条件三一定不成立，则条件一或条件二至少成立一个。
		不失一般性，假设$u \in \Suff(v)$。
		
		因为$s_x(v) \in \Suff(v), u \equsuf v$，那么$u \notin \Suff(s_x(v))$，
		否则一定有$s_x(v) \equsuf v$与函数$s_x$的定义矛盾。
		又因为$u \in \Suff(v), s_x(v) \in \Suff(v)$，那么$s_x(v) \in \Suff(u)$。
		注意，此时$u \in \Suff(v)$，因此由$s_x(v)$定义可知$s_x(v) = s_x(u)$。
	\end{proof}
	
	\begin{lem}
	\label{lem:sx_twice}
		假定$x \neq \varepsilon$, $s_x(x)$是在$x$中出现至少两次的最长后缀。
	\end{lem}
	\begin{proof}
		因为$x^{-1} \Suff(x) = \{ \varepsilon \}, x \neq_{suff(x)} s_x(x)$，
		则$\exists z \neq \varepsilon, z \in s_x(x)^{-1} \Suff(x)$。
		故$s_x(x)z, s_x(x) \in \Suff(x)$，这证明了$s_x(x)$在$x$中出现至少两次。
		
		$\forall w \in \Suff(x), |w| > |s_x(x)|$，
		由$s_x$的定义可知$w$一定满足$w^{-1} \Suff(x) = x^{-1} \Suff(x) = \{ \varepsilon \}$
		因此，$w$一定仅出现1次。
	\end{proof}
	定理~\ref{lem:sx_twice}说明了$s_x(x)$存在时，一定在$x$出现了至少两次，并且长度是最长的。
	
	\begin{lem}
	\label{lem:suf_sxu}
		假定$x \neq \varepsilon$，不妨令$u \in Fact(x) \setminus \{\varepsilon\}$，
		那么任何等价于$s_x(u)$的串都是$s_x(u)$的后缀。
	\end{lem}
	注意这里的等价是$\equsuf$。
	\begin{proof}
		不妨令$w = s_x(u), v \equsuf s_x(u)$。易知$v \equsuf w, w \in \Suff(u)$。
		
		若$v = w$，那么结论显然成立。仅需讨论$v \neq w$的情况。
		
		这里使用反证法，如果$v \notin \Suff(w)$，由引理~\ref{cor:3_cond}可知，$w \in \Suff(v)$。
		不妨令$z \in u^{-1} \Suff(x)$，
		由$w \in \Suff(u)$及~\ref{lem:u_in_sufv}可知$u^{-1} \Suff(x) \subseteq w^{-1} \Suff(x)$，
		从而有$z \in w^{-1} \Suff(x)$，又因为$v \equsuf w$，从而有$z \in v^{-1} \Suff(x)$。
		
		从而$u \in \Suff(xz^{-1}), v \in \Suff(xz^{-1})$，则$u$和$v$其中之一必定是另一个的后缀。
		
		若$u \in \Suff(v)$，由定理~\ref{lem:u_in_sufv}可得$v^{-1} \Suff(x) \subseteq u^{-1} \Suff(x)$。
		由$v \equsuf w$可知$v^{-1} \Suff(x) = w^{-1} \Suff(x)$。
		从而$w^{-1} \Suff(x) \subseteq u^{-1} \Suff(x)$，而这与~\ref{defn:sx}矛盾，故此时最初假设错误。
		
		若$v \in \Suff(u)$，同理可得$u^{-1} \Suff(x) \subseteq v^{-1} \Suff(x)$。
		而$w \in \Suff(v), v \neq w$，故$|v| > |w|$，并且$v$满足$s_x(u)$的定义，
		这也导致与$s_x(u) = w \neq v$向矛盾，故此时最初假设同样错误。
		
		从而易知假设错误，故$v \in \Suff(w)$。
	\end{proof}
	定理~\ref{lem:suf_sxu}告诉我们$\forall v \equsuf s_x(u)$，那么$v \in \Suff(s_x(u))$。
	
	\begin{lem}
	\label{lem:sx_k_equsuf_u}
		不妨令$z \in \Suff(x)$，若$u \equsuf z$且$u \in \Suff(z)$，
		令$k, k \ge 0$表示最大的整数满足$|u| \le {s_w}^k(z)$，有结论$u \equsuf {s_w}^k{z}$。
	\end{lem}
	\begin{proof}
		由$u \in \Suff(z)$，可知$|u| \le |z|$，故一定存在这样的$k$。不妨令${s_w}^k(z) = y_k$。
		
		% 不妨令
		% \begin{align*}
			% s_x(z) 		&= y_1			&\quad			\\
			% {s_x}^2(z)	&= s_x(y_1)		&=y_2			\\
			% {s_x}^3(z)	&= s_x(y_2)		&=y_3			\\
						% &\cdots			&\cdots			\\
			% {s_w}^k(z)	&= s_x(y_{k-1})	&=y_k
		% \end{align*}
		% 由定义~\ref{defn:sx}可知
		% \begin{align*}
			% z_1^{-1} \Suff(x)	&\subset	y_1^{-1} \Suff(x)	\\
			% y_1^{-1} \Suff(x)	&\subset	y_2^{-1} \Suff(x)	\\
			% y_2^{-1} \Suff(x)	&\subset	y_3^{-1} \Suff(x)	\\
								% &\cdots							\\
			% y_{k-1}^{-1} \Suff(x) &\subset	y_k^{-1} \Suff(x)
		% \end{align*}
		由定义~\ref{defn:sx}可知$y_k \in \Suff(z)$，而$u \in \Suff(z), |u| \le |y_k|$。
		因此，$u \in \Suff(y_k)$。
		由于$k$已经是目前满足$|u| \le {s_w}^k(z)$的最大值，那么不妨考虑$k+1$。显然共有两种情况。
		\begin{enumerate}[(1)]
			\item $s_x^{k+1}(z)$不存在
			
			又定义~\ref{defn:sx}可知，即$\forall y_{k+1} \in \Suff(y_k), y_{k+1} \equsuf[x] y_k$。
			而$u \in \Suff(y_k)$，故$u \equsuf[x] y_k$。
			
			\item $|u| > s_x^{k+1}(z)$
			
			由定义~\ref{defn:sx}可知$s_x^{k+1}(z) = s_x(y_k) = y_{k+1}$，
			而$u \in \Suff(y_k), |u| > |y_{k+1}|$，
			则一定有$u \equsuf[x] y_k$否则与定义~\ref{defn:sx}矛盾。
			
			故此时，$u \equsuf[x] {s_w}^k(z)$。
			
		\end{enumerate}
		综上所述，$u \equsuf[x] {s_w}^k(z)$结论成立。
	\end{proof}
	这个引理在后面至少被使用两次，然而每次作者使用的时候都将结论成立的缘由指向~\ref{lem:suf_congruence}。
	这显然有问题，毕竟$s_x$的定义再本章节才出现，因此新补充这样一个引理。
	
\subsubsection{State splitting.}
	本小节主要介绍后缀自动机在线构建的相关性质和引理。
	
	\begin{lem}
	\label{lem:sam_build_suff}
		不妨令$w \in A^*, a \in A$, $\forall u \in A^*$，有：
		\[
			u^{-1} \Suff(wa) =
			\left\{
				\begin{aligned}
					&u^{-1} \Suff(w)a \cup \{ \varepsilon \},	&\text{ if } u \in \Suff(wa),	\\
					&u^{-1} \Suff(w)a,							&\text{ otherwise }
				\end{aligned}
			\right .
		\]
	\end{lem}
	\begin{proof}
		首先考虑$\varepsilon \in u^{-1} \Suff(wa)$，这等价于$u \in \Suff(wa)$。
		因此，仅需证明$u^{-1} \Suff(wa) = u^{-1} \Suff(w)a$。
		
		不妨令$z \neq \varepsilon, z \in u^{-1} \Suff(wa)$，可知$uz \in \Suff(wa)$。
		因此，不妨令$uz = uz'a$，从而有$uz' \in \Suff(w)$，故$z' \in u^{-1} \Suff(w)$。
		从而有$z \in u^{-1} \Suff(w)a$，可知$u^{-1} \Suff(wa) \subseteq u^{-1} \Suff(w)a$。
		
		不妨令$z \neq \varepsilon, z \in u^{-1} \Suff(w)a$，可知$uz \in \Suff(w)a$。
		因此，不妨令$uz = uz'a$，从而有$uz' \in \Suff(w)$，故$z' \in u^{-1} \Suff(w)$。
		这说明$z'a \in u^{-1} \Suff(wa)$，可知$uz \in \Suff(wa), z \in u^{-1} \Suff(wa)$。
		可知$u^{-1} \Suff(w)a \subseteq u^{-1} \Suff(wa)$
		
		综上所述$u^{-1} \Suff(wa) = u^{-1} \Suff(w)a$。
	\end{proof}
	其实~\ref{lem:sam_build_suff}想想看，还是挺显然的。这也是增量法在线构建后缀自动机的基础。
	
	\begin{lem}
	\label{lem:sam_build_cong}
		不妨令$w \in A^*, a \in A$。同余关系$\equsuf[wa]$是同余关系$\equsuf[w]$的进一步细化，即
		\[
			\forall u,v \in A^*, u \equsuf[wa] v \Longrightarrow u \equsuf[w] v.
		\]
	\end{lem}
	\begin{proof}
		由$u \equsuf[wa] v$可知$u^{-1} \Suff(wa) = v^{-1} \Suff(wa)$，即证$u^{-1} \Suff(w) = v^{-1} \Suff(w)$。
		因此，仅需证明$u^{-1} \Suff(w) \subseteq v^{-1} \Suff(w)$，另一方向的证明过程对称（交换一下$u,v$就好了）。
		
		若$u^{-1} \Suff(w) = {\o}$，则结论显然成立。
		
		否则，可令$z \in u^{-1} \Suff(w)$，由定理~\ref{lem:sam_build_suff}可知$za \in u^{-1} \Suff(wa)$。
		从而有$za \in v^{-1} \Suff(wa)$，从而可知$z \in v^{-1} \Suff(w)$，从而得到
		$u^{-1} \Suff(w) \subseteq v^{-1} \Suff(w)$，证毕。
	\end{proof}
	
	给定字符串$w$的同余关系$\equsuf[w]$将$A^*$分成若干个等价类，定理~\ref{lem:sam_build_cong}
	说明$\equsuf[w]$表示的等价类是$\equsuf[wa], a \in A$表示等价类的并集。
	而事实上仅将一个或者两个等价类由于同余关系$\equsuf[wa]$会分割成两个子类，
	其中一个子类包含$w$中未出现的子串，它至少要包含字符串$wa$，$wa$这个串对类别和状态均有提升。
	定理~\ref{thm:sam_ec}和它的推论说明另一个类别如何分割。
	
	\begin{lem}
	\label{lem:longest_suf_equ}
		不妨令$w \in A^*, a \in A$，$z$是$w$中出现的$wa$的最长后缀，
		若$u$是$wa$的后缀并且$|u| > |z|$，则$u \equsuf[wa] wa$。
	\end{lem}
	\begin{proof}
		由题意易知$z \in \Suff(w)$，故$z^{-1} \Suff(wa) \neq (wa)^{-1} \Suff(wa) = \{ \varepsilon \}$。
		由~\ref{defn:sx}可知$s_{wa}(wa) = z$。
		
		而$u \in \Suff(wa), |u| > |z|$，由~\ref{defn:sx}可知必有$u \equsuf[wa] wa$，否则$s_{wa}(wa) = u \neq z$矛盾。
	\end{proof}
	% 这个定理的重要性在于划分等价类，显然说明了任何超过$z$属于$wa$后缀的串一定与$z$不属于一个等价类的。
	
	\begin{thm}
	\label{thm:sam_ec}
		不妨令$w \in A^*, a \in A$，$z$是$w$中出现的$wa$的最长后缀，
		$z'$是$w$中的最长子串并且满足$z' \equsuf[w] z$.
		$\forall u,v \in Fact(w)$，有结论：
		\[
			u \equsuf[w] v \text{ and } u \neq_{\Suff(w)} z \Longrightarrow u \equsuf[wa] v.
		\]
		进一步说，$\forall u \in A^*$，有结论：
		\[
			u \equsuf[w] z \Longrightarrow
			\left\{
				\begin{aligned}
					&u \equsuf[wa] z,	&\text{ if } |u| \le |z|,	\\
					&u \equsuf[wa] z',	&\text{ otherwise }
				\end{aligned}
			\right .
		\]
	\end{thm}
	\begin{proof}
		由$u \equsuf[w] v$可知，$u^{-1} \Suff(w) = v^{-1} \Suff(w)$，
		仅需证当$u \neq_{\Suff(w)} z$时，有$u \equsuf[wa] v$，
		即$u^{-1} \Suff(wa) = v^{-1} \Suff(wa)$。
		
		而由定理~\ref{lem:sam_build_suff}易知可以将证明原结论转化为仅需证明
		$u \in \Suff(wa) \Longrightarrow v \in \Suff(wa)$。
		
		不妨假设$u \in \Suff(wa)$，由于$u \in Fact(w)$，从而可知$u^{-1} \Suff(wa) \neq (wa)^{-1} \Suff(wa)$。
		而$s_{w}(wa) = z$及定义~\ref{defn:sx}可知$|u| < |z|$，
		从而有$u \in \Suff(z)$。则一定存在最大的整数$k$使得$|u| \le |S_w^k(z)|$。
		而${s_w}^k(z) \in \Suff(z)$，则一定有${s_w}^k(z) \in \Suff(wa)$。
		由引理~\ref{lem:sx_k_equsuf_u}可知$u \equsuf[w] {s_w}^k(z)$。而$u \equsuf[w] v$。
		则有$v \equsuf[w] {s_w}^k(z)$，显然$v \in \Suff(z), v \in \Suff(wa)$。
		
		再考虑对于单个字符串$u$的结论。\\
		由$u \equsuf[w] z$及定理~\ref{lem:u_equsuf_v}可知$u \in \Suff(z)$或者$z \in \Suff(u)$。
		
		当$|u| \le |z|$时，显然满足$u \in \Suff(z)$，故可知$u \in \Suff(wa)$，
		由定理~\ref{lem:sam_build_suff}可知$u^{-1} \Suff(wa) = u^{-1} \Suff(w)a \cap \{ \varepsilon \}$.
		同理，$v^{-1} \Suff(wa) = v^{-1} \Suff(w)a \cap \{ \varepsilon \}$，而$u^{-1} \Suff(w) = v^{-1} \Suff(w)$。
		因此，有$u \equsuf[w] z$。
		
		而当$|u| > |z|$时，$u \in w, u \equsuf z$，由定义~\ref{defn:sx}可知，
		$u \notin \Suff(wa)$，否则与$z$定义矛盾。
		$z'$是$w$中的最长子串并且满足$z' \equsuf[w] z$，而$z \in Fact(w)$。
		故一定有$|z'| \ge |z|$，当$|z'| = |z|$时，即$z = z'$，结论显然成立。
		而当$z' > z$时，具有和$u$相同的条件，因此同样可以推得$z' \notin \Suff(wa)$。
		
		故$u^{-1} \Suff(wa) = {\o}, z'^{-1} \Suff(wa) = {\o}$，
		因此$u^{-1} \Suff(wa) = z'^{-1} \Suff(wa)$，从而有$u \equsuf[wa] z'$。
		
		综上所述，结论得证。
	\end{proof}
	定理~\ref{thm:sam_ec}描述的其实是当线性构建后缀自动机时，等价类是如何变化的。
	不难发现，或者等价类仍然不变，或者与$z$或$z'$等价。
	
	\begin{cor}
	\label{cor:z_u_equsuf_v}
		不妨令$w \in A^*, a \in A$，$z$是$w$中出现的$wa$的最长后缀，
		$z'$是$w$中满足$z' \equsuf[wa] z$的最长子串。
		若$z' = z$，那么$\forall u,v \in Fact(w)$，
		$u \equsuf[w] v \Longrightarrow u \equsuf[wa] v$。
	\end{cor}
	\begin{proof}
		有定理~\ref{thm:sam_ec}可知当$u \neq_{\Suff(w)} z$时，一定有$u \equsuf[wa] v$。
		故仅需证明当$u \equsuf[w] z$时，结论同样成立。
		
		由$z' = z$及定理~\ref{thm:sam_ec}可知
		\[
			\forall u \equsuf[w] z \Rightarrow u \equsuf[wa] z
		\]
		显然$u \equsuf[wa] z$，而$u \equsuf[w] v, u \equsuf[w] z$可知$v \equsuf[w] z$。
		同理有$v \equsuf[wa] z$。易知$u \equsuf[wa] v$。
	\end{proof}
	
	\begin{cor}
	\label{cor:a_notin_w}
		不妨令$w \in A^*, \in A$，假定字符$a$并未在$w$中出现，那么
		$\forall u,v \in Fact(w)$，有结论$u \equsuf[w] v \Longrightarrow u \equsuf[wa] v$。
	\end{cor}
	\begin{proof}
		由条件易知$z = \varepsilon$，由推论~\ref{cor:z_u_equsuf_v}可知$v' \varepsilon = v$,
		从而有$u \equsuf[w] v \Longrightarrow u \equsuf[wa] v$。
	\end{proof}
	
	推论~\ref{cor:z_u_equsuf_v}和推论~\ref{cor:a_notin_w}是对增量构建后缀自动机
	状态变化情况的详细描述，说明了满足什么情况下等价类依然保持不变。
	
\subsubsection{Sizes of suffix automata.}
	
	这一小节将分别讨论后缀自动机的状态$Q$和转换边$E$的上界，同时说明后缀自动机$M(\Suff(x))$的空间复杂度为$O(|x|)$。
	
	\begin{cor}
	\label{cor:sz_Q}
		若$|x| = 0$, 则$|Q| = 1$，
		若$|x| = 1$, 则$|Q| = 2$，
		否则当$|x| \ge 2$时，$|x|+1 \le |Q| \le 2|x|-1$。
		并且当且仅当$x$形如$ab^{|x|-1}, a \neq b$时达到上界。
	\end{cor}
	\begin{proof}
		显然$|Q| \ge |x|+1$，并且当且仅当$x$形如$a^{|x|}$时达到边界。因此仅需证明$|Q| \le 2|x|-1$。
		
		易知$|x| <= 1$，结论显然成立。由定理~\ref{lem:sam_ec}可知，每当对$M(\Suff(x))$进行增量构建时，
		增加的状态数最多为2（$z$和$z'$），而当增量到2个字符时，状态数不超过3。
		故$|Q| \le 3 + 2 \times (|x| - 2) = 2|x| - 1$。
	\end{proof}
	
	定义函数$\len: Q \leftarrow \mathbb{N}$表示对$M(\Suff(x))$中的$\forall q$及其等价类中最长字符串$u$。
	它同时也是从其实状态到状态$q$的最长路径（这条路径标记为$u$）。
	$M(\Suff(x))$中的最长路径路径恰好形成了一棵生成树，这棵树中的边称为$solid$。
	等价于$\forall (p,a,q) \in E$，有：
	\[
		(p, a, q) \text{ is solid } \Longleftrightarrow \len(q) = \len(p) + 1
	\]
	定义函数$\textit{length}$是为了更清楚的说明$M(\Suff(x))$的空间的上界。
	
	\begin{lem}
	\label{lem:sz_E}
		若$|x| \ge 1$, 则$|E| \le |Q| + |x| - 2$。
	\end{lem}
	\begin{proof}
		考虑由$M(\Suff(x))$最长路径组成的生成树，显然树中共有$|Q| - 1$条边，并且每条边都是$solid$。
		
		考虑$non-solid$边$(p, a, q)$，我们定义$x$的后缀$uav$，
		$u$表示从初始状态到状态$p$的路最长径表示的子串，$v$表示从状态$q$到达终结状态最长路径表示的子串。
		显然不同的$non-solid$边对应$x$的不同后缀。而$|\Suff(x)| = |x|$，
		又因为$|x| = 1$时，$u,v = \varepsilon$，显然应该是$solid$，故$non-solid$边的上界为$|x| - 1$。
		
		综上可知$|E| \le |Q|-1 + |x|-1$，从而有$|E| \le |Q|+|x|-2$。
	\end{proof}
	
	\begin{cor}
	\label{cor:sz_E}
		若$|x| = 0$, 则$|E| = 0$;
		若$|x| = 1$，则$|E| = 1$;
		若$|x| = 2$，则$2 \le |E| \le 3$;
		否则$|x| \ge 3$，则$|x| \le |E| \le 3|x|-4$。
		并且仅当$x$形如$ab^{|x|-2}c$时达到上界。
	\end{cor}
	\begin{proof}
		观察下界$|x|$是显然的，并且仅当$x$形如$a^{|x|}$达到边界。
		
		考虑下界，不难发现当$|x| \le 2$时，结论成立。因此，仅需证明当$|x| \ge 3$时，结论同样成立。
		
		当$|x| \ge 3$时，由推论~\ref{cor:sz_Q}和引理~\ref{lem:sz_E}可知，
		$|E| \le |Q|+|x|-2, |Q| \le 2|x|-1$，故$|E| \le 3|x|-3$。
		
		而当且仅当$x$形如$ab^{|x|-1}$时，$Q$达到边界值，但此时$|E| = 2|x|-1$，显然此时$|E| \le 3|x|-4$。
		而当$|Q| \le 2|x|-2$时，代入可知$|E| \le 3|x|-4$。
		
		综上可知，$|x| \le |E| \le 3|x|-4$。
	\end{proof}
	
	\begin{thm}
	\label{thm:sz_suffix_automata}
		任意字符串的后缀自动机的空间复杂度都线性于该串的长度。
	\end{thm}
	\begin{proof}
	由推论~\ref{cor:sz_Q}和~\ref{cor:sz_E}可知，$|E|+|Q| \le 5|x|-5 = O(n)$。
	\end{proof}
	
	推论~\ref{cor:sz_Q}和推论~\ref{cor:sz_E}比较有价值，给定了较好的边界，从而说明整体的边界为$5|x|-5$。
	
\subsection{后缀自动机的构造}	
	
	后缀自动机可以采用增量法在线构建，时间复杂度和空间复杂度都是线性的，真个构造过程是高效的。
	
\subsubsection{Suffix links and suffix paths.}
	
	后缀自动机的构造主要依据于~\ref{sub:sam_property}，引入$suffix\ link$辅助条件的检测。
	其实这个东西和~\ref{sub:failure_function}很类似，使用的目的在~\ref{sub:as_strmatch_automata}。
	
	不妨使用四元组$(Q, i, T, E) = M(\Suff(x))$并且$\delta$表示转换函数。
	$\forall p \in Q \setminus \{i\}$，状态$p$表示的其实是满足关系$\equsuf[x]$的等价类，其中的元素都是$x$的子串。
	使用$u$表示等价类$p$中的任何子串，进而状态$p$的$suffix\ link$表示的其实是$s_x(u)$的同余类。
	（参考定理~\ref{thm:sam_ec}若$z \equiv p$，那么$z'$其实就是$suffix\ link$）。
	由引理~\ref{lem:sx_eq}可知$suffix\ link$与$u$的具体取值无关。
	这里引入函数$f_x$表示状态$p$到$s_x(u)$的映射。
	
	$M(\Suff(x))$的后缀路径的实际上是$suffix\ link$的迭代。
	注意如果$q = f_x(p)$，那么一定有$\len[x](q) < \len[x](p)$。从而，序列
	\[
		(p, f_x(p), {f_x}^2(p), \cdots)
	\]
	一定是有穷的并且最终结束于起始状态$i$。这样的序列称为状态$p$的后缀路径。
	
	后缀自动机$M(\Suff(x))$的状态$last_x$表示$x$自身的等价类。显然状态$last_x$没有任何出边，从而$last_x$的后缀路径可以表示成
	\[
		(last_x, f_x(last_x), {f_x}^2(last_x), \cdots)
	\]
	这条路径是后缀自动机建立的关键路径。
	
	\begin{prop}
	\label{prop:sx_fx}
		不妨令$u \in Fact(x) \setminus \{ \varepsilon \}$并且令$p = \delta(i, u)$。
		从而有结论$\forall k \ge 0$，若${s_w}^k(u)$存在，那么一定有${f_x}^k(p) = \delta(i, {s_w}^k(u))$。
	\end{prop}
	\begin{proof}
		当$k = 0$时，结论即是已知，故显然成立。
		
		故不妨令$k \ge 1$并且${s_w}^k(u)$存在，使用数学归纳法假设${f_x}^{k-1}(p) = \delta(i, s_x^{k-1}(u))$。
		由$f_x$的定义可知$f_x({f_x}^{k-1}(p))$表示$s_x(s_x^{k-1}u)$的同余等价类。
		故可知${f_x}^{k-1}(p) = \delta(i, s_x^{k}(u))$。
	\end{proof}
	
	\begin{cor}
	\label{cor:sam_t_lastx}
		后缀自动机$M(\Suff(x))$中的终结态集合$T$，恰好是状态$last_x$的后缀路径上的状态集合。
	\end{cor}
	\begin{proof}
		令$p$表示$last_x$所在后缀路径上的其中一个状态，从而有$\exists k \ge 0$，$p = {f_x}^k(last_x)$。
		由于$last_x = \delta(i, x)$及命题~\ref{prop:sx_fx}可知，${f_x}^k(last_x) = \delta(i, {s_w}^k(x))$。
		从而有$p = \delta(i, {s_w}^k(x))$。
		
		若$p \in T, u \in \Suff(x), p = \delta(i, u)$。由于$u \in \Suff(x)$，不妨令$k \ge 0$为同时满足
		$|u| \le |{s_w}^k(x)|$的最大整数值。
		
		由引理~\ref{lem:sx_k_equsuf_u}可知$u \equsuf[x] {s_w}^k(x)$，故有$p = \delta(i, {s_w}^k(x))$。
		由命题~\ref{prop:sx_fx}可知，$p = {f_x}^k(u), u \in \Suff(x)$，则$p$一定在$last_x$的后缀路径中。
		
		综上结论成立。
	\end{proof}
	
\subsubsection{On-line construction.}
\label{subsub:sam_online_construct}

	本节主要说明后缀自动机在线构造的方法，简单说就是每个阶段构建前，
	都已经形成了基于$x$的前缀$x_1 x_2 \cdots x_{\ell}$的后缀自动机$M(\Suff(x_1 x_2 \cdots x_{\ell}))$。
	这个自动机的终结态由$last_{x_1 x_2 \cdots x_{\ell}}$的后缀路径隐式说明。
	在构建过程中可以显示地使用变量来表示状态$last_{x_1 x_2 \cdots x_{\ell}}$。
	% 这就是SAM-Build过程中的last
	
	除此外，还使用了其它两个变量：$Length$和$F$。
	$Length$数组表示函数$\len[x]$，有~\ref{sub:sam_property}节可知$solid$边或者$non-solid$均与这个函数有关。
	$F$数组用来表示状态的$suffix\ link$，其本质就是$f_x$函数。
	
	后缀自动机的在线构造包括SA-EXTEND过程和后续的预处理过程
	（该过程将$M(\Suff(x_1 x_2 \cdots x_{\ell-1}))$建立的转换函数转化为当前串的自动机$M(\Suff(x_1 x_2 \cdots x_{\ell}))$）。
	\begin{codebox}
	\Procname{$\proc{SuffixAutomata}(x)$}
		\zi let $\delta$ be the transition function of $(Q, i, T, E)$
		\li $(Q, E) \gets ({\O}, {\O})$
		\li $i \gets \proc{State-Creation}()$
		\li $Length[i] \gets 0$
		\li $F[i] \gets \const{nil}$
		\li $last \gets i$
		\li \For $\ell \gets 1$ \To \attrib{x}{length}
		\li		\Do $\proc{SA-Extend}(\ell)$
				\End
		\li	$T \gets {\O}$
		\li	$p \gets last$
		\li \kw{Do}
        \li     \Do
				$T \gets T + \{p\}$
		\li		$p \gets F[p]$
                \End
		\li	\kw{While} $p \neq \const{nil}$
		\li \Return $((Q, i, T, E), Length, F)$
	\end{codebox}
	
	\begin{lstlisting}[frame=shadowbox,framexleftmargin=5mm,rulesepcolor=\color{gray},numbers=none]
		SA-Extend(\ell)
		a \leftarrow x_{\ell}
		newlast \leftarrow State-Creation
		Length[newlast] \leftarrow Length[last] + 1
		p \leftarrow last
		loop E \leftarrow E + {(p, a, newlast)}
			 p \leftarrow F[p]
			while p \neq NIL and \delta(p,a)=NIL
		if p = NIL
			then F[newlast] \left i
			else q \leftarrow \delta(p, a)
				 if Length[q] = Length[p] + 1
					then F[newlast] \leftarrow q
					else q' \leftarrow State-Creation
						 for each letter b such that \delta(q, b) \neq NIL
							loop E \left E + {(q', b, \delta(q, b))}
						 Length[q'] \leftarrow Length[p] + 1
						 F[newlast] \leftarrow q'
						 F[q'] \leftarrow F[q]
						 F[q] \leftarroww q'
						 loop E \leftarrow E - {(p, a, q)} + {(p, a, q')}
							  p \leftarrow F[p]
							while p \neq NIL and \delta(p, a) = q
		last \leftarrow newlast
	\end{lstlisting}
	
	\begin{thm}
	\label{thm:sam_build_right}
		$\forall x$，函数\proc{SuffixAutomata}可以构建$x$的后缀自动机。
	\end{thm}
	\begin{proof}
		后缀自动机构造过程的正确性使用数学归纳法对已经建立的$x$长度进行归纳推理。
		
		首先，考虑当$x = \varepsilon$，显然此时的后缀自动机仅包含一个状态$i$，即是初始态也是终结态。
		此时，上述构造过程显然正确。
		
		然后，考虑$x \neq \varepsilon$，这也意味着$|x| \ge 1$，故不妨令$w \in A^*, a \in A$使得$x = wa$。
		使用数学归纳法，我们假定当处理到$w$时，已经建立的后缀自动机$M(\Suff(w))$是正确的。
		状态集合及转换函数分别用$Q$和$E$表示。
		
		显然，此时$last = \delta(i,w)$。同时，对于$\forall r \in Q$，有$Lengh[r] = length_w(r)$，
		而对于$\forall r \in Q \setminus \{i\}$，有$F[r] = f_w(r)$。
		
		故我们仅需证明，当使用字符$a$对$M(\Suff(w))$进行增量构造后，得到的自动机$M(\Suff(wa))$是正确的。
		所谓$M(\Suff(wa))$，首先要保证所有终结态的集合表示的恰好是$\Suff(x)$，同时$M(\Suff(x))$的转换函数是正确的。
		
		SA-EXTEND过程首先建立新的状态$newlast$表示的最长后缀$x$，显然有$\delta(last_w, a) = newlast$。
		同时，这条边是$solid$，而$Length[newlast] = Length[last] + 1 = length_x(x)$也保证$Length$的更新正确。
		
		SA-EXTEND过程中的变量$p$其实是在对$last_w$的所有$suffix\ path$路径进行搜索，
		在循环停止前，均加入边$(p, a, newlast)$，使得这些节点更新为$x$的后缀。
		当循环结束时，可能有如下三种情况：
		\begin{enumerate}[(1)]
			\item $p$为空；
			\item $(p, a, q)$是$solid$边；
			\item $(p, a, q)$是$non-solid$边。
		\end{enumerate}
		
		因为后缀自动机的边根据$solid$定义仅分成两类，故上述三种情况确实是完备的。
		进而，我们仅需要根据三种不同情况分别证明。
		\begin{enumerate}[\text{Case} (1).]
			\item $p$为空
			
			当且仅当$w$中从未$a$满足这种情况。显然，这说明了$s_x(x) = \varepsilon$，
			故使用$f_x(newlast) = i$是正确的，从而$F[newlast] \leftarrow i$。
			而对于$\forall r \in Q$由推论~\ref{cor:a_notin_w}可知，等价类不发生变化，
			故其它$f_w(r) = f_x(r)$，而显然这种情况$newlast$是唯一的终结态。
			
			\item $(p, a, q)$是$solid$边
			
			不妨令$u$表示最长的子串满足$\delta(i, u) = p$。
			由$length_x$的定义可知$|u| = length_x(p) = Length[p]$，
			又因为${s_x}^k(w) < {s_x}^{k-1}(w)$，可知$ua$一定是出现在$w$中的$wa$的最长后缀。
			注意，这个结论一定成立是因为这条边是$solid$，因而有$length_x(q) = length_x(p) + 1$，
			那么$\delta(i, ua) = q$一定成立。
			即$ua = s_x(x)$，而由$f_x$定义可知$f_x(newlast) = q$，故$F[newlast] = q$。
			
			不妨令$z = ua = s_x(x)$，由定理~\ref{thm:sam_ec}可知对于任何与$q$不等价的其它等价类仍然保持原有的等价关系。
			因此，仅需要考虑与$z$在$w$中等价的串是否在$x$依然与$z$等价。
			不妨令$z'$表示$w$中与$z$等价的最长子串，即$|z'| \ge |z|$。
			由$length_x$定义可知$|z'| \le |z|$，显然$z' = z$，由推论~\ref{cor:z_u_equsuf_v}可知
			$\forall v \equsuf[w] z \Longrightarrow v \equsuf[wa] z$。
			
			显然此时的终结态集合同样正确。
			
			\item $(p, a, q)$是$non-solid$边
			
			不妨令$u$表示最长的子串满足$\delta(i, u) = p, z = ua$，$z'$表示最长的子串满足$\delta(i, z') = q$。
			显然$\delta(i, z) = q$，但$|ua| < |z'|, ua \in \Suff(z')$，但是$ua = s_w(wa)$。
			
			由~\ref{thm:sam_ec}的进一步解释可知，$\forall v \equsuf[w] z$，必须将其分割成两个等价类。
			即$|v| \le |z|$与$v \equsuf[x] z$，而其它的$v \equsuf[x] z'$。
			
			过程SA-EXTEND先创建了新的状态$q'$表示$z$，而原有的状态$q'$表示$z'$，
			显然这个过程保证$|v| > |z|$仍然保持等价关系，而$|v| \le |z|$变为与$z$等价。
			而$s_x(x) = z = ua, s_x(z') = z$均显然成立。因此，易知$F$的更新也是正确的。
			
			最后考虑，为什么后面还要加一个循环？在执行循环前$\forall v, q = \delta(i, v)$。
			在执行循环后$\forall v, |v| \le |z|, q' = \delta(i, v)$，而$|v| > |z|$，仍然有$q = \delta(i, v)$。
			重点是$|v| \le |z|$仅出现在$p$的$suffix\ path$路径上。而当$\delta(p,a) \neq q$时，
			那么此时的$\delta(p,a)$不可能$\equsuf[w] z$。
			
		\end{enumerate}
		
		综上，证明了后缀自动机的增量构建过程是正确的。
	\end{proof}
	理解上述的证明过程，关键是要理解定理~\ref{thm:sam_ec}及其推论。
	后缀自动机的每个状态表示的不是单个串，而是一个等价类。
	而对于一个等价类，使用最长串表示$length_x$表示的是这个串在$x$的最右端下标，
	而由引理~\ref{lem:u_equsuf_v}可知其它串一定是这个最长串的后缀。
	由引理~\ref{lem:sx_eq}可知，一个等价类的$f_x$是相同的。
		
	
\subsubsection{复杂度}
\label{subsub:sam_build_complex}

	为了分析后缀自动机构造过程的复杂度，我们需要假定使用邻接表实现这样一个自动机。
	从而，增加边、更新边、查询转换函数等操作都可以在$O(\log |A|)$时间内完成。
	$f_x$函数采用数组$F$实现，因此$f_x$的查询可以在$O(1)$时间内完成。
	
	使用$Length$数组表示$length_x$，同时使用布尔变量表示邻接表中的边是否为$solid$。

	\begin{thm}
	\label{thm:sam_online_construct_complex}
		对于给定的字符串$x$，SuffixAutomata函数可以在时间复杂度$O(|x| \times |A|)$及空间复杂度$O(|x|)$构建它的后缀自动机。
	\end{thm}
	\begin{proof}
		后缀自动机$M(\Suff(x))$、$Length$、$F$的空间复杂度都是$O(|Q|)$，邻接表的空间复杂度为$O(|E|)$。
		由推论~\ref{cor:sz_Q}和~\ref{cor:sz_E}可知它们的复杂度等价于$O(|x|)$。
		故空间复杂度$O(|x|)$证毕。
		
		显然SuffixAutomata出SA-EXTEND循环外，其余操作均满足复杂度$O(|x| \times |A|)$。
		因此，考虑均摊，即执行SA-EXTEND的总体复杂度不超过$O(|x| \times |A|)$。
		
		这个均摊，作者必然是没说清楚的。我也没有什么太好的方法证明。
		% 但是可以参考failure function。除了增加结点因此导致$f_x$重定向外，$f_x$是不更新的。
		% 因此，下一次搜索的$suffix\ path$与前一次有很大重合，那么前一次处理了$a$，下一次当再次处理$a$时，
		% 一定不会搜索到初始位置，故$O(|x| \times |A|)$是一个界。均摊后，SA-EXTEND的上界就是$O(|A|)$。
		我认为可以这么理解，每次SA-EXTEND的第一次循环跳过的结点，下一次不会再被搜索。
		因为显然，下一次从$last$开始搜索，而$F[last] = q$。因此，总共至多跳过$O(|x|)$个结点，
		考虑邻接表查询边的复杂度则为$O(|A|)$，所以均摊后每次调用SA-EXTEND的复杂度是$O(|A|)$。
		
		显然整体的复杂度为$O(|x| \times |A|)$。
	\end{proof}

	
\subsection{作为字符串下标}
\label{sub:as_index}

	基于字符串$x$的后缀自动机自然地提供了其子串的下标。
	我们考虑如下4个坐标的基本操作：成员、初始位置、出现次数、位置列表。
	使用后缀自动机同样可以有效地计算字符串中子串的数目，同时最长的子串至少出现两次。
	
\subsubsection{Membership.}
\label{subsub:idx_membership}

	\begin{prob}
	\label{prob:index_membership}
		\Emph{(Membership problem for Fact(x).)}
		对于给定的字符串$w \in A^*$，找到它属于$Fact(x)$的最长前缀。
	\end{prob}
	
	\begin{prop}
		给定后缀自动机$M(\Suff(x))$，计算给定字符串$w$的最长前缀$u$并且$u \in Fact(x)$的过程，
		可以在$O(|u| \times \log |A|)$时间内完成。
	\end{prop}
	\begin{proof}
		在$M(\Suff(x))$搜索字符串$u$，当首次出现$\delta(p, u_k) = \varepsilon$时跳出搜索循环，
		此时的前缀$u_1 u_2 \cdots u_{k-1}$极为所求解。显然这个过程可以在$O(|u| \times |A|)$内完成。
	\end{proof}
	
\subsection{First position.}
\label{subsub:idx_fp}
	
	\begin{prob}
	\label{prob:index_fir_pos}
		\Emph{(Frist position of w in x.)}
		对于给定的$w \in Fact(x)$，找到它在字符串$x$中首次出现的位置。
	\end{prob}
	
	首先我们假定$w \in Fact(x)$（测试$w$是否在$x$中可以直接在自动机中搜索$x$），
	原问题在$x$中搜索$w$首次出现的位置$fp_x(w)$，等价于计算$endpos_x(w)$，显然
	\[
		fp_x(w) = endpos_x(w) - |w|.
	\]
	更却求地说，这等价于计算$x$中的子串$w$的右端上下文的最大长度
	\[
		lc_x(w) = \max \{ |z| | z \in w^{-1} Fact(x) \}.
	\]
	（注意$endpos$定义使用的是$\min$，而$lc$这里定义使用的是$\max$，这是极大-极小定理的应用）。
	因为
	\[
		fp_x(w) = |x| - lc_x(w) - |w|.
	\]
	与之相反的，找到$w$在$x$中的最末位置$lp_x(w)$，可以通过计算右端上下文的最小值实现。因为，
	\begin{align*}
		sc_x(w) = \min \{ |z| | z \in w^{-1} Fact(x) \}.	\\
		lp_x(w) = |x| - sc_x(w) - |w|.
	\end{align*}
	因此，为了高效地计算初始位置或最末位置，我们可以对$lc$或者$sc$进行预处理。
	
	\begin{prop}
		后缀自动机$M(\Suff(x))$可以在$O(|x|)$时间内进行预处理，
		从而$\forall w, w \in Fact(x)$可以在$O(|x| \times \log |A|)$时间和$O(|x|)$空间内
		确定初始位置或最末位置。
	\end{prop}
	\begin{proof}
		首先，定义$LC$：
		对于状态$p$和字符串$u$满足$p = \delta(i, u)$，有$LC[p] = lc_x(u)$。
		注意到，$LC[p]$与$u$的具体值无关。
		由引理~\ref{lem:u_equsuf_v}可知$v \equsuf[x] u$，则必定有$lc_x(u) = lc_x(v)$。
		因此数组$LC$满足如下归纳关系：
		\[
			LC[p] =
			\left\{
				\begin{aligned}
					&0,				&\text{ if } p = last_x,	\\
					&1 + \max \{ LC[q] | q = \delta(p, a), a \in A \}, &\text{ otherwise }
				\end{aligned}
			\right .
		\]
		显然可以通过深搜在$O(|Q|)$时间内计算每个状态的$LC$值，因此该过程的时间复杂度是$O(|x|)$。
		
		为了计算$fp_x(w)$，我们首先要找到状态$p$满足$\delta(i, w) = p$，
		值$|x| - |w| - LC[p]$就是所求解。由命题~\ref{prop:index_membership}可知
		这个过程的时间复杂度是$O(|w| \times \log |A|)$。
		
		同理，定义$SC$：
		对于状态$p$和字符串$u$满足$p = \delta(i, u)$，有$SC[p] = sc_x(u)$，使用如下归纳关系计算$SC$:
		\[
			SC[p] =
			\left\{
				\begin{aligned}
					&0,			&\text{ if } p \in T,	\\
					&1 + \min \{ SC[q] | q = \delta(p, a), a \in A \},	&\text{ otherwise }
				\end{aligned}
			\right .
		\]
		计算过程同样采用深搜，故预处理的时间复杂度为$O(|x|)$，而查询的复杂度为$O(|u| \times \log |A|)$。
		
	\end{proof}
	
\subsubsection{Occurrence number.}
\label{subsub:idx_on}

	\begin{prob}
		\Emph{(Number of occurrences of w in x.)}
		对于给定的字符串$w, w \in Fact(x)$，求$w$在$x$中出现的次数。
	\end{prob}
		
	\begin{prop}
		后缀自动机$M(\Suff(x))$可以在$O(|x|)$时间内进行预处理，
		从而使得计算$\forall w, w \in Fact(x)$在$x$中出现次数可以在$O(|x| \times \log |A|)$及空间$O(|x|)$内完成。
	\end{prop}
	\begin{proof}
		$w$在$x$的出现此时可以表示为
		\[
			|\{ z | z \in A^* \text{ and } wz \in \Suff(x) \}|.
		\]
		若$\delta(i, w) = p$，可以转化为
		\[
			|\{ z | z \in A^* \text{ and } wz \in \Suff(x) \}|.
		\]
		不妨令$NB[p]$表示上式值，同时满足如下递归关系式：
		\[
			NB[p] =
			\left\{
				\begin{aligned}
					&1 + \sum_{q = \delta(p, a),a \in A} NB[q],     &\text{ if } p \in T,   \\
					&\sum_{q = \delta(p,a), a \in A} NB[q],         &\text{ otherwise }.
				\end{aligned}
			\right .
		\]
		显然这也是一个树形DP，同样可以深搜在$O(|x|)$时间内计算出所有状态$p$的$NB$值。
		
		然后，对于给定字符串$w$，先求出状态$p$满足$\delta(i, w) = p$，就是在$M(\Suff(x))$上进行深搜。
		由命题~\ref{prop:index_membership}可知，这个过程的复杂度为$O(|w| \times \log |A|)$。
		
		显然结论成立。
	\end{proof}
	
	另一个与之相似的问题是求$x$中的子串数量。事实上，$Fact(x)$是右端上下文与初始状态$i$关联的特殊状态。
	通过计算右端数量$CS[p]$可以计算子串数量，$CS[p]$d的计算满足如下递归关系式：
	\[
		CS[p] =
		\left\{
			\begin{aligned}
				&1,			&\text{ if } p = last_x,	\\
				&1 + \sum_{q = \delta(p, a), a \in A} CS[q],	&\text{ otherwise }.	\\
			\end{aligned}
		\right .
	\]
	从而可以得到$x$的子串数量：
	\[
		|Fact(x)| = CS[i].
	\]
	显然，这又是一个树形DP，复杂度依然是$O(|x|)$。
	这个树形DP中累加求和的是当前状态$p$的$\equsuf[x]$的串数量。
	最终$CS[i]$其实是包括空串的$CS[i]-1$是所有非空子串的数量。
	
\subsubsection{List of positions.}
\label{subsub:idx_lop}
	
	\begin{prob}
		\Emph{(Positions of w in x.)}
		给定字符串$w, w \in Fact(x)$，求$w$在$x$中出现位置的列表。
	\end{prob}
	
	\begin{prop}
		后缀自动机$M(\Suff(x))$可以在$O(|x|)$时间内预处理，使得
		$w$在$w$出现的位置列表可以在$O(|w| \times \log |A| + |L|)$时间及$O(|x|)$空间内计算。
	\end{prop}
	\begin{proof}
		预处理自动机进行缩点，将那些仅包含一条结点并且目标结点是非终结态的结点缩点。
		而这等价于在原有后缀自动机$M(\Suff(x))$上叠加了新的图。
		显然，这个图的结点要么是终结状态、要么是包含两条出边的状态。
		其中的每个结点代表了从$i$搜索到该结点的字符路径。
		
		假定在$M(\Suff(x))$对字符串$w$进行搜索，并且$\delta(i, w) = q$。
		因此，位置列表就是以$q$为根的子树的所有的位置的并集。
		显然由根结点$q$开始对子树进行遍历即可找到位置列表，
		显然子树中结点不超过$2|L|$，故遍历的时间复杂度是$O(|L|)$。
		由命题~\ref{prop:index_membership}可知搜索字符串$w$的复杂度为$O(|w| \times \log |A|)$。
		
		故整体的时间复杂度为$O(|w| \times \log |A|)$。
	\end{proof}
	
\subsubsection{Longest repeated factor.}
\label{subsub:idx_lrf}
	
	通过使用$x$的后缀自动机可以解决两类问题：
	\begin{itemize}
		\item 找到$x$的最长重复子串
		\item 找到$x$中仅出现一次的最短子串
	\end{itemize}
	
	\begin{prob}
		\Emph{(Longest repeated factor in x.)}
		给定字符串$x$，找出最长的子串$w \in Fact(x)$并且$w$在$x$中出现至少两次。
	\end{prob}
	若计算$x$中子串重复次数的数组$NB$已经被预处理。
	从而原问题转化为找到$M(\Suff(x))$中的最深状态$p$并且$NB[p]>1$。
	从初始状态$i$到状态$p$的字符路径即是所求解。
	
	事实上即使不使用$NB$也可以解决该问题。
	我们仅仅需要考虑最深的状态$p$并且同时满足如下两个条件：
	\begin{enumerate}[(1)]
		\item $p$的出度至少为$2$；
		\item $p$为终结点并且$p$的出度至少为$1$。
	\end{enumerate}
	
	\begin{prop}
	\label{prop:idx_lrf_complex}
		使用后缀自动机$M(\Suff(x))$，计算$x$中的最长重复子串可以在时间复杂度$O(|x|)$内实现。
	\end{prop}
	\begin{proof}
		显然第二种方法可以在$O(|x|)$内实现。
	\end{proof}
	
	给定字符串$x$的最长重复子串，$ua \in Fact(x), a \in A$。
	显然$ua$是在$x$中出现一次的最短子串。
	因此，推论~\ref{prop:idx_lrf_complex}同时满足这两个问题。
	
	这显然也是极大-极小定理的应用之一。
	P.S. 离散数学真的很重要。
	
\subsection{作为字符串匹配自动机}
\label{sub:as_strmatch_automata}
	
	基于字符串$x$的后缀自动机$M(\Suff(x))$可以用来解决字符串匹配问题，即定位字符串$x$在字符串$y$中的出现位置。
	搜索过程类似于在线对$y$进行搜素。此外，$M(\Suff(x))$还需要failure function的支持，
	而$suffix\ link$在这里等价于failure function。
	
\subsubsection{Ending factors.}
\label{subsub:strmacth_end_factor}

	EndingFactors过程计算在$y$的每个位置出现的$x$的最长子串，更确切地说是这个子串的长度。使用$\ell_k$表示
	\[
		\forall k \in [0, |y|], \ell_k = \max \{ |w| | w \in \Suff(y_1 y_2 \cdots y_k) \cap Fact(x) \}
	\]
	EndingFactors可以在线计算最长结尾子串的序列$(\ell_k)_{0 \le k \le |y|}$。
	它以由$\{0, \cdots, |x|\}$的字符组成的字符串作为输出结果。
	~\ref{sub:sam_property}引入的函数$length_x$用来对使用$suffix\ link$遍历后对当前长度进行恢复。
	
	EndingFactors函数的核心是使用$F$数组在转换过程中进行计算。
	\begin{lstlisting}[frame=shadowbox,framexleftmargin=5mm,rulesepcolor=\color{gray},numbers=none]
		Ending-Factors((Q, i, T, E), Length, F, y)
			let \delta be the transition function of (Q, i, T, E)
			(\ell, p) \leftarrow (0, i)
			L \leftarrow 0
			for letter a from first to last letter of y
				loop if \delta(p, a) \neq NIL
					then (\ell, p) \leftarrow (\ell+1, \delta(p, a))
					else loop p \leftarrow F[p]
							while p \neq NIL and \delta(p, a) = NIL
						 if p \neq NIL
							then (\ell, p) \leftarrow (Length[p]+1, \delta(p, a))
							else (\ell, p) \leftarrow (0, i)
					 L \leftarrow L \cdot \ell
			return L
	\end{lstlisting}
	
	\begin{thm}
		EndingFactors过程计算字符串$y$中的$x$的最长结尾子串的时间复杂度为$O(|y| \times \log |A|)$，空间复杂度为$O(|x|)$。
		在$M(\Suff(x))$中，$y$至多执行$2|y|$次状态转换
	\end{thm}
	\begin{proof}
		因为$f_x$函数实际上等价于failure function，过证明过程与定理~\ref{thm:ac_automata_complex}过程及其类似，此处略。
	\end{proof}
	
\subsubsection{suffix links的优化.}	
	
	实际上我们大可以使用另外一种函数$\hat{f_x}$代替$f_x$函数，从而优化搜索的延迟。
	引入后缀自动机$M(\Suff(x))$的状态$q$的Follow集合的定义：
	\[
		Follow_x(q) = \{ a | a \in A, \delta(q, a) \text{ is defined. } \}
	\]
	进而，可以递归定义$\hat{f_x}$：
	\[
		\hat{f_x}(q) =
		\left\{
			\begin{aligned}
				&f_x(q),			&\text{ if } Follow_x(f_x(q)) \nsubseteq Follow_x(q),	\\
				&\hat{f_x}(f_x(q)),	&\text{ otherwise }.
			\end{aligned}
		\right .
	\]
	注意到这里的$\hat{f_x}$可能会未定义。
	
	Follow集合的性质可以简化$\hat{f_x}$的计算。
	在后缀自动机中，总是有$Follow_x(q) \subset Follow(f_x(q))$。
	这是因为$f_x(q)$对应于$u$的最长后缀$v$，而$u$满足$\delta(i, u) = q$。
	因此，$u$的Follow集合一定是$v$的Follow集合的子集。
	使用这个性质，可以重新定义$\hat{f_x}$：
	\[
		\hat{f_x}(q) =
		\left\{
			\begin{aligned}
				&f_x(q),		&\text{ if } deg_q \neq deg_{f_x(q)},	\\
				&\hat{f_x}(f_x(q)),	&\text{ otherwise }.
			\end{aligned}
		\right .
	\]
	因此，$\hat{f_x}$仅仅需要考虑状态的出度，故可以再线性时间内预处理。
	
	\begin{prop}
		使用$\hat{F}$数组表示$\hat{f_x}$函数的EndingFactors过程的$delay$复杂度是$O(|A|)$。
	\end{prop}
	\begin{proof}
		由于$Follow_x(q) \subset Follow_x(\hat{f_x}) \subseteq |A|$，因此$delay$复杂度为$O(|A|)$。
	\end{proof}
	
\subsubsection{Searching for rotations.}
	
	$(\ell_k)_{0 \le k \le |y|}$的相关内容使用于如下使用场景：
	搜索字符串$y$中的$x$，计算$(x,y)$的最长公共子串，或者计算连个字符串间的$subword$距离：
	\[
		d(x, y) = |x| + |y| - 2 \times lcf(x, y).
	\]
	$x$在$y$中的位置依赖于如下简单观察：
	\[
		\ell_k = |x| \Longleftrightarrow x \text{ occurs at position } k - |x| \text{ in } y.
	\]
	$(\ell_k)$同样适用于解决字符串的共轭（rotation）问题：
	当字符串$v,w \in A^*, u = vw$时，字符串$u$的共轭是$wv$。

	\begin{prob}
		\Emph{(Searching for rotations.)}
		给定字符串$x, x \in A^*$，找到字符串$y$中$x$共轭的所有位置。
	\end{prob}
	
	第一种解法是构建基于$x$所有共轭的$trie$树，然后进行搜索。然后，这样一个$trie$的空间复杂度是$O(|x|)$的。
	
	基于后缀自动机的解法可以将空间复杂度优化为线性。
	
	\begin{prop}
		在执行时间复杂度为$O(|x| \times \log |A|)$的预处理后，
		$y$中所有$x$共轭的位置可以再时间复杂度$O(|y| \times \log |A|)$及空间复杂度$O(|x|)$内求出。
	\end{prop}
	\begin{proof}
		显然字符串$x \cdot x$中任何长度为$|x|$的子串都是$x$的共轭。
		同时，长度大于$|x|$的子串一定包含长度为$x$的共轭作为后缀。
		
		解决方案变更为构建后缀自动机$M(\Suff(xx))$，并且跑一遍修改后的EndingFactors：
		当$\ell_k \ge |x|$时，保留$k - |x|$。
		
		事实上，当且仅当$x \cdot x$的最长子串在$k$位置结尾时长度不小于$x$。
		因此，$w$的长为$x$的后缀才是$x$的共轭。
		
		显然，此时的时间复杂度不变。
	\end{proof}
	
\subsection{Factor Automata}	
\label{sub:factor_automata}
	
\subsubsection{Relation to suffix automata.}

\subsubsection{Size of factor automata.}

\subsubsection{On-line construction.}
	
	
\end{document}
