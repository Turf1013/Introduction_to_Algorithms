%-*- coding:UTF-8 -*-
% TaxiSharing.tex
\documentclass[hyperref,UTF8]{ctexart}
\usepackage{geometry}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{amsthm}
\usepackage{listings} %插入代码
\usepackage{xcolor} %代码高亮
\usepackage{blkarray}
\usepackage{diagbox}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{color}
\usepackage{multirow}
\usepackage[all,pdf]{xy}
\usepackage{verbatim}   %comment
\usepackage{cases}
\usepackage{clrscode3e}	% need clrscode3e package which is not included in CTex.
\usepackage{hyperref}

\geometry{screen}
\hypersetup{
    colorlinks=true,
    bookmarks=true,
    bookmarksopen=false,
    % pdfpagemode=FullScreen,
    pdfstartview=fit,
    pdftitle={TaxiSharing},
    pdfauthor={Trasier}
}

% THEOREM Environments --------------------------------------------------------
\newtheorem{thm}{Theorem}[subsection]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{prob}[thm]{Problem}
\newtheorem{mthm}[thm]{Main Theorem}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\numberwithin{equation}{subsection}
% MATH ------------------------------------------------------------------------
\DeclareMathOperator{\RE}{Re}
\DeclareMathOperator{\IM}{Im}
\DeclareMathOperator{\ess}{ess}
\newcommand{\eps}{\varepsilon}
%\newcommand{\To}{\longrightarrow}  conflict with \package{clrscode3e}p
\newcommand{\h}{\mathcal{H}}
\newcommand{\s}{\mathcal{S}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\BOP}{\mathbf{B}}
\newcommand{\BH}{\mathbf{B}(\mathcal{H})}
\newcommand{\KH}{\mathcal{K}(\mathcal{H})}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Complex}{\mathbb{C}}
\newcommand{\Field}{\mathbb{F}}
\newcommand{\RPlus}{\Real^{+}}
\newcommand{\Polar}{\mathcal{P}_{\s}}
\newcommand{\Poly}{\mathcal{P}(E)}
\newcommand{\EssD}{\mathcal{D}}
\newcommand{\Lom}{\mathcal{L}}
\newcommand{\States}{\mathcal{T}}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\seq}[1]{\left<#1\right>}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\essnorm}[1]{\norm{#1}_{\ess}}


% Some setup
\pagestyle{plain}
\geometry{a4paper, top=2cm, bottom=2cm, left=2cm, right=2cm}
\CTEXsetup[format={\raggedright\bfseries\Large}]{section}
\lstset{numbers=left, %设置行号位置
        numberstyle=\small, %设置行号大小
        keywordstyle=\color{blue}, %设置关键字颜色
        commentstyle=\color{purple}, %设置注释颜色
        %frame=single, %设置边框格式
        escapeinside=``, %逃逸字符(1左面的键)，用于显示中文
        breaklines, %自动折行
        extendedchars=false, %解决代码跨页时，章节标题，页眉等汉字不显示的问题
        %xleftmargin=2em,xrightmargin=2em, aboveskip=1em, %设置边距
        tabsize=4, %设置tab空格数
        showspaces=false %不显示空格
       }

% About math
\newcommand{\rmnum}[1]{\romannumeral #1}
\newcommand{\Emph}{\textbf}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\resetcounter}{\setcounter{equation}{0}}
\newcommand{\equsuf}[1][x]{\equiv_{\textit{Suff(#1)}}}	
\newcommand{\Suff}{\textit{Suff}}
\newcommand{\len}[1][x]{\textit{length}_{#1}}

% section deeep to 3 1.1.1
\setcounter{secnumdepth}{3}

\begin{document}

\title{\Huge TaxiSharing}
\vspace{2cm}
\author{\Large Trasier}
\date{\today}
\maketitle

\section{Problem Statement}
\label{sec:problem_statement}
	
	现有一家外卖公司请你来帮助解决其外卖配送问题。
	该公司的外卖平台现负责$R$个餐厅与$D$个小区间的外卖配送任务，
	有$M$个配送员，平台每天都会受到许多来自$D$个小区居民的订单，
	每个订单包含如下信息：
	\begin{itemize}
		\item 下单时间$time_k$
		\item 接单餐馆$rid_k$
		\item 目地小区$did_k$
	\end{itemize}
	假设配送员在任意两点的移动时间均为这两点的欧几里得举例（由于题目假设移动速度为），
	并且配送员在到达餐厅时总能立即取到餐，在到达送餐目的地时总能立刻把外卖送给顾客。
	每位配送员有一个最多能容纳$C$份外卖的配送箱（假设每份外卖的体积相等），初始位置由你给定。
	请针对如下两类场景分别求解问题:
	\begin{enumerate}[(1)]
		\item 静态场景：假设你已经提前知道了所有的订单信息，请设计一种分配方案，
		以最小化外卖平台上所有点餐用户中的最长等待时间。
		\item 动态场景：无法提前或者订单信息，只有在订单出现后才为期分派配送员。
		请设计一种分配方案，以最小化外卖平台上所有点餐用户中的最长等待时间。
	\end{enumerate}

\section{Test Case Generation}
\label{sec:test_case_generation}
		
\subsection{输入格式}	
	
	数据以如下格式给出：	\\
	第一行5个数$R,D,M,C,N$，分别代表餐厅数目、小区数目、配送员数目、配送箱数量以及订单数目。	\\
	接下来$R$行，每行两个数$x_i, y_i(1 \le i \le R)$表示第$i$个餐厅的坐标。	\\
	接下来$D$行，每行两个数$x_j, y_j(1 \le j \le D)$表示第$j$个小区的坐标。	\\
	接下来$N$行，每行三个数$time_k, rid_k, did_k(1 \le k \le N)$表示第$k$个订单的下单时间，下单餐馆编号以及配送的目地小区编号。	\\

\subsubsection{样例输入}
	
    \begin{gather*}
	\begin{matrix}
		2 &2 &1 &2 &2	\\
		1 &1 &\ &\ &\ 	\\
		1 &2 &\ &\ &\ 	\\
		100 &1 &\ &\ &\ 	\\
		100 &2 &\ &\ &\ 	\\
		1 &1 &1 &\ &\ 	\\
		10 &2 &2 &\ &\ 	\\
	\end{matrix}
    \end{gather*}
	
\subsection{输出格式}

	我们要求以如下格式输出你设计的配送方案：	\\
	配送方案包括$M$组，分别对应每个配送员的配送路径。每组方案应以如下格式输出：	\\
	第一行包含两个整数：$id_i, num_i(1 \le i \le M)$表示当前方案为第$id_i$个配送员的方案，共有
	$num_i$个关键点（能够表示该配送员配送路径的一系列点）。	\\
	接下来$num_i$行，每行首先包含5个数$x_t, y_t, arrive_t, leave_t, bucket_t$表示
	该配送员于$arrive_t$时刻到达坐标$(x_t, y_t)$位置，并于$leave_t$时刻从该位置离开，
	离开时配送箱中包含的外卖数为$bucket_t$。之后给出$bucket_t$个数，
	分别表示这$bucket_t$个外卖所对应的订单编号。	\\
	在配送方案输出完成后，最后一行输出最长的等待时间$Time$。

	
\section{Notes}	
\label{sec:notes}

\section{Tool}
\label{sec:tool}

\subsection{Schedule}

Schedule工具的主要功能是用来观察订单请求和路线规划的关系，
它的主要优点在于可以实时地看到规划的路线是否符合设计初衷。
并且，更容易观察导致最长bound的路线产生的原因，是否可以进一步优化。

本着简单修改Topcoder Marathon Visit程序即可以实现路线规划的模拟成员。
该模拟程序主要需要实现如下几个部分：
\begin{enumerate}[(1)]
	\item 方格形状结点显示餐馆，三角形状显示小区。红色结点表示当前订单。
	\item 实现表示正在行进的路线
	\item 每隔设定秒数刷新一次图片
	\item 不同的driver采用不同的颜色显示图片
	\item 以progressbar显示以餐馆为目标的尚未pickup 的订单数
	\item 以progressbar显示以订单为目标的尚未dropoff 的订单数
\end{enumerate}

\section{Thought}
\label{sec:thought}

\subsection{Motivation}

\subsubsection{From the perspective of driver}

从司机或者车的角度看，假设在任意时刻都有$|driver| > |rider|$，那么也意味着我一定可以最优化地
从站点发车，然后每次都载一个乘客。虽然，这种情况不一定是最优解（因为存在路上捡单的情况）。但是，
显然这样的解至少不会特别差（只要站点的设置是合理的）。

基于这个思路，动态的拼车则意味着对于每个请求，选择最合适的$driver$。如果当前没有driver，则等待。
当然这也不一定是最优解，但是可以动态地解决问题。
与划分时间窗口，使用静态的方法解决问题相比。如果时间窗口特别小，那么实际上与没有窗口立即响应相同
（这是由于汽车的位移并不多）；相反地，如果窗口足够大，虽然汽车的位移发生了变化，但是极大地影响了用户体验，
而且这种情况下用户可能取消订单。


\subsection{Baseline}
\label{subsec:baseline}
	
考虑最原始的配送情况，根据订单的先后顺序，选择当前Free 的Driver配送，如果当前没有Free的Driver，则加入等待队列中。
即任何时候，每个配送员仅有一个单。	

\subsection{贪心}
\label{subsec:greedy}

\subsubsection{基于时间窗口的重规划}

现有算法的主要缺陷在于下单后，一旦将该单分配给driver，则始终由该driver配送，尽管当该单请求时，
路线满足局部最优。但随着，插入新的订单后，该单不发保证从上一时刻到当前的最优解。
而此时，有很多单还没有pickup。而这些尚且没有pickup的单完全可以重新规划，即由其它的配送员配送。

基于时间窗口的重规划算法，即当每个订单下单后，直接由配送员配送。
每隔一定时间窗口，对这些订单重新洗牌。在洗牌时，保持原有的已经pickup尚未deliver的订单。
问题，转化为如何规划一堆订单的配送路线。将未pickup的结点聚成cluster，然后插入到已有路线后。

\subsection{基于tshare的优化(错误版)}

贪心的策略几乎都类似于tshare。
目前仅仅想到了优化策略，优化的主要目标是时间复杂度，
主要思路是采用动态规划，优化的前提是以最小化最大等待时间为前提。

tshare算法的计算量都主要集中在枚举两个插入结点，然后形成新的路径，
从而完成了路径规划。
由于是枚举两个结点，因此平均情况下，这部分子程序的时间复杂度为$O((\frac{M}{N})^2)$。
这部分子程序的调用次数是$MN$。
因此，如果可以将这部分子程序的时间复杂度优化为线性，可以很大程度上减少程序的执行时间。

使用$S$表示当前路线，
当前路线包含$n$个结点，
不妨使用$0 \rightarrow 1 \rightarrow 2 \cdots \rightarrow (n-1)$。
使用$T[i]$表示到达结点$i$的时间。
使用$C[i]$表示到达结点$i$的容量（执行pickup或者dropoff 后）。
使用$F[i]$表示当前结点是否为dropoff位置。
使用$Slack[i]$表示结点$i$的时间剩余量。
使用$bound$表示当前的最大等待时间。

一次遍历$S$，刻意计算$T,C,F$，进一步刻意计算出$Slack$。
\begin{align*}
	&\text{当} F[i]=0 \text{时}, slack[i] = slack[i+1]	\\
	&\text{当} F[i]=1 \text{时}, slack[i] = \min{slack[i+1], begTime+bound-T[i]}
\end{align*}

先考虑插入一个结点，即在结点$i$和$i+1$间插入结点$n$，
从而得到路线$S' = 0 \rightarrow \cdots i \rightarrow n \rightarrow (i+1) \rightarrow \cdots \rightarrow (n-1)$。

令$\delta = Length(i,n) + Length(n,i+1) - Length(i,i+1)$，
$\forall j>i$，有$T'[j] = T[j] + \delta$。
因此，当$slack[j] > \delta$时，显然$bound$保持原值，
当$slack[j] \le \delta$时，$bound$会增加。
为了快速地判断$bound$是否会增加，增加辅助数组$D$。
\[
	D[i] = min(max(0,\delta-slack[j]), D[i+1]);
\]

再插入第二个结点时，刻意利用前一次的$D$数组
求得对于当前结点的最优方法，选择对$bound$增长最少的插入策略
作为最新的路线。
对于多种$bound$不增长的策略，选择插入结点靠后的方式。

\newpage
\subsection{基于tshare的优化(最新版)}

使用$Pos[i]$表示结点$i$对应的坐标。
使用$Oid[i]$表示结点$i$对应的订单编号，使用$Tid[i]$表示结点$i$对应的订单的起始时间。从而有
\[
    Tid[i] = Orders[Oid[i]].tid
\]
使用$Br[i]$表示区间$[i,sz]$内的最大bound值，使用$Bl[i]$表示区间$[0,i]$内的最大bound值。
\begin{align*}
    Br[i] &= \max\{\forall j\in[i,sz], F[j]*(T[j] - Tid[j])\} \\
    Bl[i] &= \max\{\forall j\in[0,i], F[j]*(T[j] - Tid[j])\}
\end{align*}
插入两个结点$p,d$，$p$表示pickup位置，$d$表示dropoff位置，$t_0$表示下单时间。并且满足$p \in [0,sz], d \in [p,sz]$。
使用$dval[i]$表示在$i$后插入结点$d$后的新bound值（当前路线的bound），使用$dcost[i]$表示在$i$后插入结点$d$的路线最小增量。
使用$dpos[i]$表示在$i$后插入结点$d$的最佳位置。\\
当在$i-1$和$i$间插入结点$d$后，可以计算$d$结点导致的路线增量$delta$。
\begin{align*}
    delta &= Length(Pos[i-1], d.pos) + Length(d.pos, Pos[i]) - Length(Pos[i-1], Pos[i]) \ge 0 \\
    arrive &= T[i-1] + Length(Pos[i-1], d.pos)
\end{align*}
从而可以计算新路线$0 \rightarrow 1 \cdots \rightarrow (i-1) \rightarrow d \rightarrow i \cdots \rightarrow sz$的总开销为
$T[sz] + delta$。\\
进一步，可以得到
\begin{align*}
    dval[i] &= \min_{\forall j\in[i,sz]}
        \max \left\{
            \begin{aligned}
                F[k]*(T[k]-Tid[k]), &\text{ if } k \in [i,j) \\
                F[k]*(T[k]-Tid[k]+delta[j]), &\text{ if } k \in [j, sz] \\
				T[j] + arrive[j] - t_0, &\text{ }
            \end{aligned}
        \right .    \\
            &= \min_{\forall j\in[i,sz]}
		\max \left\{
            \begin{aligned}
                F[k]*(T[k]-Tid[k]), &\text{ if } k \in [i,sz] \\
                F[k]*(T[k]-Tid[k]+delta[j]), &\text{ if } k \in [j, sz] \\
				T[j] + arrive[j] - t_0, &\text{ }
            \end{aligned}
        \right .    \\
			&= \min_{\forall j\in[i,sz]}
		\max \left\{
			\begin{aligned}
				&\max \{\forall k\in[i,sz], F[k]*(T[k]-Tid[k])\} \\
				&\max \{\forall k\in[j,sz], F[k]*(T[k]-Tid[k]+delta[j])\} \\
				&T[j] + arrive[j] - t_0
			\end{aligned}
		\right . 	\\
			&= \min \{dval[i+1], \max\{Br[i], F[i]*(T[i]-Tid[i]+delta[i], T[i]+arrive[i]-t_0)\} \} \\
			&= \min \{dval[i+1], \max\{F[i]*(T[i]-Tid[i]+delta[i]), T[i]+arrive[i]-t_0\}\} \\
\end{align*}
不妨令$B = \max\{F[i]*(T[i]-Tid[i]+delta[i]), T[i]+arrive[i]-t_0\}$
从而可以计算$dcost$和$dpos$。
\begin{align*}
	dcost[i] &= \left\{
		\begin{aligned}
			dcost[i+1], &\text{ if } dval[i+1] \le B \\
			delta[i], &\text{ if }	dval[i+1] > B
		\end{aligned}
	\right . \\
	dpos[i] &= \left\{
		\begin{aligned}
			dpos[i+1], &\text{ if } dval[i+1] \le B \\
			i, &\text{ if }	dval[i+1] > B
		\end{aligned}
	\right .
\end{align*}
当插入$p$点时，可以利用$dval, dcost, dpos$加快计算，使用$t_0$表示新订单的起始时间。
使用$val[i]$表示在$i$位置插入点$p$后，可能的最优路线bound，
使用$cost[i]$表示该路线对应的时间开销，使用$dropLoc$表示最优的$d$点位置。\\
同理，插入结点$p$后的$delta$为
\[
	delta_p = Length(Pos[i-1], p.pos) + Length(p.pos, Pos[i]) - Length(Pos[i-1], Pos[i]) \ge 0
\]
使用$j$表示结点$d$的插入位置，使用$delta_d$表示插入结点$d$的路线增量。此时，可以分三种情况讨论：
\begin{enumerate}[(1)]
	\item $i == j$ \\
	此时路径的增量为
	\[
		delta = Length(Pos[i-1], p.pos) + Length(p.pos, d.pos) + Length(d.pos, Pos[i]) - Length(Pos[i-1], Pos[i])
	\]
	先计算辅助变量$tmp$，
	\begin{align*}
		tmp &= \max_{\forall k\in[0,n]} \left \{
			\begin{aligned}
				F[k] * (T[k]-Tid[k]), &\text{ if } k\in[0,i) \\
				F[k] * (T[k]-Tid[k]+delta), &\text{ if } k\in[i,sz]
			\end{aligned}
		\right . \\
			&= \max \{Br[0], Br[i]+delta\} \\
	\end{align*}
	从而可以计算$val, cost$。
	\begin{align*}
		val &= \max\{tmp, T[i-1]+Length(Pos[i-1], p.pos) + Length(p.pos, d.pos) + Length(d.pos, Pos[i])-t_0\} \\
		cost &= T[sz] + delta
	\end{align*}
	
	\item $j == sz$ \\
	此时路径的增量为
	\[
		delta = Length(Pos[sz-1], p.pos) + Length(p.pos, d.pos)
	\]
	从而，可以较容易得求得
	\begin{align*}
		val &= \max\{Br[0], T[sz]+delta-t_0\} \\
		cost &= T[sz] + delta
	\end{align*}
	
	\item $j \in (i, sz)$ \\
	此时路径的增量为
	\begin{align*}
        arrive_d &= T[j-1] + Length(Pos[j-1], d.pos) \\
		delta_p &= Length(Pos[i-1], p.pos) + Length(p.pos, Pos[i]) - Length(Pos[i-1], Pos[i]) \\
		delta_d &= Length(Pos[j-1], d.pos) + Length(d.pos, Pos[j]) - Length(Pos[j-1], Pos[j]) \\
		delta   &= delta_p + delta_d
	\end{align*}
	先计算辅助变量$tmp$
	\begin{align*}
		tmp &= \min_{\forall j\in(i,sz)}
			\max \left\{
				\begin{aligned}
					F[k]*(T[k]-Tid[k]+delta_d), 		&\text{ if } k \in (i,j) \\
					F[k]*(T[k]-Tid[k]+delta_d+delta_p), &\text{ if } k \in [j,sz) \\
					T[j]+delta_p+arrive_d-t_0, 		&\text{ }
				\end{aligned}
			\right . 	\\
			&= delta_d + \min_{\forall j\in(i,sz)}
			\max \left\{
				\begin{aligned}
					F[k]*(T[k]-Tid[k]), 		&\text{ if } k \in (i,j) \\
					F[k]*(T[k]-Tid[k]+delta_p), &\text{ if } k \in [j,sz) \\
					T[j]+arrive_d-t_0, 		&\text{ }
				\end{aligned}
			\right . 	\\
			&= delta_d + dval[i+1]
	\end{align*}
	从而，可以容易求得
	\begin{align*}
		val &= \max\{Bl[i-1], tmp\} \\
		cost &= T[sz] + delta_d + dcost[i+1] \\
		pos &= dpos[i] \\
	\end{align*}

	
\end{enumerate}

\newpage
\section{总结}
	
	
\end{document}
